# 毕业设计（论文）  

题 目： 基于 Unity 的模拟经营游戏的设计与实现  

学院： 信息科学与工程学院  
专业： 软件工程 班级：2101 学号： 202103140137  
学生姓名： 梁峰铭  
导师姓名： 邬思奇  
完成日期： 2025 年 5 月 24 日  

# 诚 信 声 明  

# 本人声明：  

1、本人所呈交的毕业设计（论文）是在老师指导下进行的研究工作及取得的研究成果；  

2、据查证，除了文中特别加以标注和致谢的地方外，毕业设计（论文）中不包含其他人已经公开发表过的研究成果，也不包含为获得其他教育机构的学位而使用过的材料；  

3、我承诺，本人提交的毕业设计（论文）中的所有内容均真实、可信。  

作者签名：  

日期：2025 年 5 月 24 日  

# 目 录  

摘要.  
Abstract .. II  
第 1 章 绪 论 ...1.1 引言 .1.2 研发背景及意义.1.3 国内外研究现状1.3.1 人工智能在游戏开发中的研究现状..1.3.2 寻路算法研究与应用.1.3.3 游戏 NPC 行为模拟技术1.4 研究目的及内容 41.4.1 研究目的 .. 41.4.2 研究内容 ... .41.5 研究方法及框架. .41.5.1 研究方法 .. .41.5.2 研究框架 . 51.5.3 技术路线 .  
第2 章相关概念与技术介绍.. 62.1 相关概念界定. .62.1.1 游戏人工智能 ..2.1.2 非玩家角色 .2.1.3 寻路算法 . 62.1.4 行为调度系统 . 62.2 相关技术基础.2.2.1 Unity 引擎介绍.2.2.2 相关工具介绍 ..2.2.3 相关算法介绍 .... .8  
第3 章系统前期分析. .113.1 系统需求分析. .113.1.1 项目背景与目标 .. 11  

3.1.2 用户分析 ... .11  
3.2 系统功能需求分析... .12  
3.2.1 A\*寻路系统 .. .12  
3.2.2 NPC 行为调度系统. 12  
3.2.3 NPC 动作控制系统.. .13  
3.2.4 场景交互系统 .. ..13  
3.3 非功能性需求分析.. ...14  
3.3.1 性能需求 .. .14  
3.3.2 可用性需求 . 14  
3.3.3 可扩展性需求 .... .15  
3.3.4 可测试性需求 . ......15  
3.4 系统可行性分析.. ......15  
3.4.1 技术可行性 .. .15  
3.4.2 经济可行性 .. .16  
3.4.3 操作可行性 .. ..16  
3.4.4 总体可行性评估 .. ..16  
第4 章系统设计与实现.. .18  
4.1 模拟经营游戏开发平台与工具. .18  
4.2 模拟经营游戏开发过程. ..18  
4.3 模拟经营游戏功能的设计与实现. .....19  
4.3.1 游戏整体设计流程图 ..19  
4.3.2 游戏开始界面与开场动画设计与实现. .22  
4.3.3 游戏角色控制设计与实现. 24  
4.3.4 游戏地图系统设计与实现... ..27  
4.3.5 游戏背包系统设计与实现... ..29  
4.3.6 游戏时间系统设计与实现.. ......31  
4.3.7 游戏种植系统设计与实现. ..33  
4.3.8 游戏交易系统设计与实现. .36  
4.3.9 游戏 NPC 交互系统设计与实现. .. 39  
4.3.10 游戏数据存储系统设计与实现. ..42  
4.4 模拟经营游戏性能优化分析.. .46  
4.4.1 游戏 NPC 寻路优化策略 46  
4.4.2 对象池技术与内存管理优化 .49  
4.4.3 多线程处理与 Job System 优化 50  
4.5 美术资源管理 .50  
第5 章游戏测试及运行效果总结 .51  
5.1 游戏测试案例 .51  
5.1.1 角色控制系统测试用例 51  
5.1.2 NPC 系统测试用例 52  
5.1.3 物品与背包系统测试用例 52  
5.1.4 交易系统测试用例. 53  
5.1.5 时间与环境系统测试用例. 54  
5.1.6 种植系统测试用例. .55  
5.1.7 系统性能测试用例 .56  
5.2 游戏运行效果总结 .57  
5.2.1 游戏功能运行效果总结 57  
5.2.2 游戏运行性能效果总结. .59  
结 论.. .63  
参考文献. .64  
致 谢. .65  

# 基于Unity 的模拟经营游戏的设计与实现  

摘要：随着游戏行业蓬勃兴起，基于Unity 引擎的模拟经营类游戏，因其有较高自由度以及趣味性，深受玩家青睐，成为游戏开发领域备受关注的热门方向，在此背景下，本文依托Unity 引擎，着手设计并成功实现了一款以农场为题材的模拟经营类游戏，这款游戏囊括背包管理、种植收获、交易经济、NPC 交互以及存档等多个核心功能模块，运用MVC 架构与模块化设计思路，使得系统拥有良好的可扩展性以及可维护性。在功能实现环节，借助ScriptableObject 对静态数据进行管理，融合有限状态机即FSM 与A\*路径规划来控制NPC 行为，凭借协程以及事件系统达成作物生命周期管理，同时构建了动态交易系统与UI交互界面，在性能优化方面，系统采用对象池技术、Unity Job System等方式，切实提升了运行效率以及内存利用率。借助Unity Profiler 等工具在目标平台展开测试评估，结果说明本系统在中低配置设备上依旧可维持稳定帧率以及流畅交互体验，该项目为模拟经营类游戏开发提供了可复用的技术范式，同时有较强的教学与研究参考价值。  

关键词：Unity；模拟经营；游戏开发；模块化架构；性能优化  

# The Design of a Simulation Management Game Based on Unity  

Abstract：With the vigorous development of the gaming industry, simulation management games based on the Unity engine have gained deep popularity among players for their high degree of freedom and fun, becoming a hot direction in the game development field. This paper designs and implements a farm-themed simulation management game based on the Unity engine. The game mainly contains several important functional parts, such as managing items in the warehouse, planting and harvesting crops, economic systems for buying and selling things, interacting with the characters in the game, and archiving functions. Technically, the game uses the MVC architecture, and adopts a modular design idea, which is more convenient to add new functions or modify existing functions in the future. Specifically, the data in the game is controlled by ScriptableObject, and NPC behavior is achieved through finite state machine and $\mathbf { A } ^ { * }$ .In order to make the game run more smoothly, the development of the object pool technology and Unity's Job System method, which both improves the speed and saves memory. The actual test uses tools such as Unity Profiler, and it is found that even on a mobile phone with a low configuration, the game can keep the screen and operate smoothly. This project shows how to use Unity to develop simulation and business games, and the technical methods used are also very helpful for other similar game development.  

Keywords:Unity; Simulation Management; Game Development; Modular Architecture; Performance Optimization  

# 第1 章 绪 论  

# 1.1 引言  

信息技术与智能终端的飞速发展给数字娱乐产业迎来了前所未有的繁荣期，电子游戏自20 世纪末起步以来，在中国大陆市场已经历了20 余年的发展，不仅已经从最初的单一娱乐工具演变为集互动性、教育性与沉浸感于一体的综合媒介，更是在电子游戏的收入上超越美国，跃居世界第一大电子游戏市场，成为我国在文化娱乐产业发展领域中的重要支柱[1]。不仅如此，2022 年中共中央办公厅、国务院办公厅印发的《“十四五”文化发展规划》提出：“鼓励文化单位和广大网民依托网络平台依法进行文化创作表达，推出更多优秀的网络文学、综艺、影视、动漫、音乐、体育、游戏产品和数字出版产品、服务……发展积极健康的网络文化。”在这样的背景下，游戏产业受到国家的大力支持，被赋予了新时代引领年轻一代培养积极进取精神、弘扬中华优秀传统文化的责任，利用先进科学技术，促进当代文化传播，例如《黑神话：悟空》走出中国，走向世界，对我国传统文化的弘扬以及培养文化自信起到了不可替代的重要作用。  

在众多游戏类型中，模拟经营类游戏凭借其独特的开放性、策略性与高自由度深受各年龄段玩家的青睐。不同于《英雄联盟》、《王者荣耀》等竞技类游戏往往需要玩家投入大量的时间和精力，较强的竞技性往往会加重玩家的压力与负担，恰恰违背了业余玩家日常玩游戏的大多是为了在繁忙之中获取放松心情的目的，此类游戏通过资源管理、策略安排和系统优化等多种机制，引导玩家在虚拟世界中模拟现实生活的如农业种植、城市管理、商业运营等各类场景，在潜移默化中锻炼玩家的逻辑思维与问题解决能力[2]，达到放松身心的效果。  

Unity 引擎在游戏开发领域有强大的跨平台能力、丰富的开发工具链以及活跃的社区支持，成为全球备受欢迎的实时3D 开发平台之一，Unity 所提供的物理引擎、动画系统、可视化编辑器以及其生态系统中的Asset Store，为中小型开发团队乃至个人开发者提供了极大便利与创造空间。借助Unity，开发者可高效搭建复杂的游戏逻辑与界面系统，且依据Unity 引擎极高的灵活性，开发者可以为多个平台开发游戏并轻松部署至如iOS、安卓、Windows 等端口，覆盖更广泛的用户群体。而且Unity 引擎还提供了诸多服务，如内容发布平台Unity Asset Store(UAS），其中UAS 的插件、素材、开发者社区、用户手册等都可以很好地帮助开发者开发游戏。本研究以Unity 引擎作为开发平台，围绕“模拟经营”这一游戏类型展开设计与实现，聚焦于农场题材背景，构建一个有完整功能体系、良好用户交互体验以及较高技术质量的模拟经营游戏项目。借助本课题的研究和实践，可深入理解游戏系统架构与模块设计的方法，还可以掌握Unity 引擎在实际开发中的综合应用能力，为日后从事游戏开发、软件工程或相关方向奠定坚实基础。  

# 1.2 研发背景及意义  

2022 年，中共中央办公厅、国务院办公厅印发的《“十四五”文化发展规划》提出：“鼓励文化单位和广大网民依托网络平台依法进行文化创作表达，推出更多优秀的网络文学、综艺、影视、动漫、音乐、体育、游戏产品和数字出版产品、服务……发展积极健康的网络文化。”在这样的背景下，游戏产业受到国家的大力支持，被赋予了新时代引领年轻一代培养积极进取精神、弘扬中华优秀传统文化的责任，利用先进科学技术，促进当代文化传播[3]，例如《黑神话：悟空》走出中国，走向世界，对中国传统文化的弘扬以及培养文化自信起到了不可替代的重要作用。  

进而电子游戏已经从最初的休闲消遣逐步演变为一种融合教育、社交、文化传播、经济模拟等多重功能的综合性媒介，如在主流游戏内展现现实社会中某品牌产品的广告、游戏角色穿戴现实世界中某品牌服装饰品等产品等,虚拟流量若是加以合理运用,也会带来可观的经济效益[4]。在诸多游戏类型中，模拟经营类游戏因其自由度高、内容丰富、节奏平缓而深受广大玩家喜爱且又通常以资源管理、环境建设、角色互动等要素为核心来赋予玩家强烈的控制感与成就感广泛应用于个人娱乐、认知训练、商业模拟及教育等多个场景之中[5]。  

模拟经营类游戏是一种着重强调过程控制以及系统反馈的游戏形态，早在在上世纪的时候就已经诞生了一些经典作品，像《模拟城市》《铁路大亨》等，随着技术不断进步以及用户需求发生变化，这类游戏逐渐从简单的规则驱动朝着高度可定制的沙盒式玩法发展，在这样的背景之下开展研究并且实现一款有代表性的模拟经营游戏有着关键的理论价值以及实践意义。  

从教育方面来看，模拟经营游戏有很强的启发性和实践价值，在不受现实物理、经济以及资源限制的条件下，它可同时模拟真实世界的决策过程，让玩家在游戏里体验“做决策－看结果－再优化”的循环思维，特别适合用于系统思维与逻辑训练，农场类模拟游戏还可引导玩家了解农业经济、自然生态以及资源管理等知识内容，把教育融入娱乐之中，激发玩家兴趣[6]。  

从技术层面来讲，模拟经营游戏系统复杂，模块众多，包含了数据管理、用户界面、物理交互、AI 行为、路径规划以及性能优化等诸多关键技术，以Unity 作为开发基础进行完整的项目实践，可全面锻炼开发者的系统架构思维与编码能力，也可以作为学习图形学、人工智能、数据结构等课程内容的应用延伸。  

从产业发展角度而言，国内外游戏市场对高质量独立游戏的需求不断增长，这些玩家更加关注玩法创新、内容深度以及技术表现力，模拟经营类游戏因为其可持续的内容更新和高度粘性的玩法机制，成为近年来独立游戏创业的热点方向，在本科阶段进行相关课题的研究与实现，可掌握行业发展趋势，还为未来就业或者创业提供有力支持。  

# 1.3 国内外研究现状  

# 1.3.1 人工智能在游戏开发中的研究现状  

人工智能在游戏开发中的应用已有数十年历史，从早期简单的有限状态机到现代复杂的决策系统，AI 技术在游戏中的应用不断发展。在国际上大型游戏公司如EA、育碧等在NPC 行为模拟方面投入大量研究资源，开发出如《刺客信条》系列中的人群模拟系统和《模拟人生》中的自主决策系统。在国内游戏开发中米哈游、腾讯等公司也在积极探索AI 技术在游戏中的应用。与国外相比国内的研究更注重结合中国市场特点，开发符合本土玩家习惯的AI 系统，如《逆水寒》的AI 角色“沈秋索”能根据玩家对话实时进行反应，甚至还会产生情绪的变化；腾讯公司的《和平精英》的“吉莉”接入大模型后，还可与玩家进行积极互动，如今有了AI 赋能，为其注入生命，这些NPC 一改以往只会重复台词的机械感，不仅能推动剧情，还会学习玩家偏好，形成长期情感联结，让玩家拥有游戏角色如同真人的感受[7]。  

# 1.3.2 寻路算法研究与应用  

A\*算法因其效率和准确性使得开发的游戏人物相对于其他的普通游戏有着更加好的寻路智能, 明显改善了游戏的可玩性，进而在游戏开发中得到广泛应用[8]，在国际上Epic Games 公司的 Unreal Engine 以及 Unity Technologies 公司的 Unity 引擎当中都内置了基于A 的导航系统，研究人员还开发出了像是Theta、JPS 等A 的变体，目的在于提高特定场景下的性能，而在国内，关于寻路算法方面的研究主要聚焦于优化传统算法，根据全局路径关键节点分段应用动态规划，弥补全局规划的缺陷，使其可适应移动平台的限制，使角色能够实现避障，另外也涉及针对大规模开放世界游戏的寻路优化工作[9]。  

# 1.3.3 游戏 NPC 行为模拟技术  

在NPC 行为模拟方面，国际研究主要集中在行为树、效用AI 和基于目标的行动规划（GOAP）等技术，像《The Last of Us》和《Red Dead Redemption 2》等游戏展示了高度真实的沉浸式NPC 行为系统使得NPC 能够根据游戏世界的变化做出合理反应。而国内的研究则更多关注于如何在有限计算资源下实现令人满意的NPC 行为，特别是在移动游戏平台上，又由于现在国内游戏产业的快速发展，可以见到越来越多的企业和学术机构开始研究更加复杂和真实的NPC 行为模拟技术[10]。  

# 1.4 研究目的及内容  

# 1.4.1 研究目的  

本研究是要基于Unity 引擎来设计并且实现一个高效可复用且后期可扩展的模拟经营游戏，这个系统要完成最基础的农场经营游戏的基本功能包括不限于角色控制、种植经营、交易采集等，同时关键在NPC 人工智能系统来探索未来游戏NPC 发展趋势，主要解决这些问题：设计一个广泛且较为容易实现的模拟经营游戏范式，设计能让NPC在复杂地形中找到最优路径的高效A\*寻路算法，开发让NPC 依据游戏内时间执行不同任务的基于时间调度的NPC 行为系统，达成NPC 与游戏环境以及玩家的自然交互，优化算法性能，减少资源占用，提升游戏运行效率。  

# 1.4.2 研究内容  

本研究的重点内容是开发一个较为完整的农场模拟经营游戏，在完善背包管理、种植收获、交易经济、NPC 交互等基本系统后，可以进行正常游玩体验，并将深入对NPC系统进行深度的探索，包括不限于基本动画、交互和与其他系统联动。  

# 1.5 研究方法及框架  

# 1.5.1 研究方法  

本研究计划采用以下方法：  

（1）文献研究法：通过研究国内外相关文献，掌握游戏AI 和寻路算法的最新研究  
成果。（2）实验研究法：在Unity 引擎中设计实验，验证算法的正确性和性能。（3）系统开发法：遵循软件工程原则，进行需求分析、系统设计、编码实现和测  
试。（4）对比分析法：将实现的AI 系统与现有解决方案进行对比，分析优缺点。  

# 1.5.2 研究框架  

本研究构建的框架有以下几个层次，基础层囊括网格节点系统、节点数据结构以及移动步骤数据，算法层包含A\*寻路算法实现，其作用是计算最优路径，行为层有NPC行为调度系统，用于管理NPC 依据游戏内时间执行的任务，控制层有NPC 移动控制、动画切换等功能，交互层负责处理NPC 与玩家、环境之间的交互。  

# 1.5.3 技术路线  

本研究的技术路线如下：  

（1）使用Unity 引擎作为开发平台。  
（2）采用面向对象编程方法，使用C#语言进行开发。  
（3）基于网格的A\*寻路算法实现。  
（4）使用Unity 的动画系统实现NPC 的动画控制。  
（5）设计基于时间的调度系统管理NPC 行为。  
（6）利用Unity 的物理系统处理碰撞检测和物理交互。  

# 第 2 章相关概念与技术介绍  

# 2.1 相关概念界定  

# 2.1.1 游戏人工智能  

游戏人工智能（Game AI）是指在游戏中模拟智能行为的技术，与学术界的通用人工智能不同的一点是游戏AI 更注重实用性和游戏体验。在本项目中的游戏AI 主要体现为NPC 的行为模拟例如包括路径规划、决策制定和动作执行等方面。游戏AI 的目标是创造出“足够聪明”的角色，使其行为看起来合理而有说服力并同时避免消耗过多计算资源。  

# 2.1.2 非玩家角色  

非玩家角色（Non-Player Character）指的是那些由计算机来进行控制，并非玩家亲自操控的游戏角色，NPC 涉及了游戏里的多种类型，比如村民、商人、敌人或者任务提供者等等，在当前这个项目当中，NPC 作为实现AI 系统的关键载体，借助赋予它自主行动的能力以及日常行为模式，以此来提升游戏世界的真实感以及沉浸感。  

# 2.1.3 寻路算法  

寻路算法指的是在游戏场景里，为角色寻觅出从起始点抵达终点的最佳路线的算法[11]，优良的寻路算法应能在合理的计算资源条件下，找出避开障碍物的最短路径或者最优路径，于游戏开发而言，寻路算法是NPC 移动的关键技术，它的基本目标是为虚拟对象或智能体寻找到达目的地的最佳路径，对游戏中角色移动的自然程度以及智能水平有着直接影响。  

# 2.1.4 行为调度系统  

行为调度系统是一种依据特定条件来安排NPC 执行不同行为的系统，该系统可让NPC 依照预设的规则自动进行行为切换，形成有规律的日常活动，以此提升游戏世界的动态特性以及生命力，在本项目里，时间调度属于NPC 行为系统的关键构成部分，它可使NPC 依据游戏内的时间去执行不同的任务。  

# 2.2 相关技术基础  

# 2.2.1 Unity 引擎介绍  

Unity 是一款跨平台的游戏开发引擎，如今已成为全球颇为受欢迎的游戏开发工具之一，Unity 引擎有如下特点与优势：其一，拥有跨平台开发能力，它支持将应用构建至多个平台，覆盖 Windows、macOS、iOS、Android、WebGL 等，这让开发者可一次进行编码，便可在多平台部署。其二图形渲染系统表现出色，Unity 提供了强大的2D 以及3D 图形渲染功能，支持多种光照模型、材质系统以及各类视觉效果，借此可达成高质量的游戏画面，其三物理系统也较为突出，内置的物理引擎可模拟现实世界的物理效果，包含刚体动力学、碰撞检测、关节连接等，使游戏中的物体表现得更为真实。其四动画系统也有独特之处，Unity 的动画系统 Animator 支持复杂的角色动画以及状态管理，可实现角色动作的平滑过渡以及复杂动画序列，其五脚本编程有其便利之处，Unity 主要把C#用作脚本语言，依靠MonoBehaviour 类提供组件式开发模式，让开发者可方便地实现游戏逻辑。其六资源管理较为高效，Unity 的资源管理系统支持资源的导入、优化以及加载，便于管理游戏中的模型、纹理、音频等资源，在本项目里，Unity 引擎为NPC 人工智能系统的实现提供了基础平台，其组件式架构和脚本系统，使得AI 行为的设计与实现变得更加模块化且灵活。  

# 2.2.2 相关工具介绍  

Visual Studio 是由微软公司所开发的集成开发环境，也就是IDE，它是Unity 开发时的首选编辑器，该编辑器有代码编写、调试以及版本控制等功能，其智能提示以及调试工具十分强大，极大地提升了开发效率，在本项目当中，Visual Studio 被用来编写和调试C#脚本，以此实现NPC 的AI 逻辑。Unity 的Tilemap 系统是一款用于创建和管理基于网格的2D 游戏场景的工具，借助 Tilemap，开发者可迅速构建游戏地图，还可以定义地形属性以及碰撞区域，Tilemap 系统在本项目里会用于构建游戏场景，并且为寻路算法提供网格化的地图数据，Unity Animator 是Unity 引擎内部的动画控制系统，它以状态机的形式管理动画切换以及参数控制。在本项目中，Animator 用于管理NPC 的动画状态，达成行走、站立等动作的平滑切换，提高NPC 行为的视觉呈现效果，ScriptableObject 是Unity 提供的数据容器，用于存储与场景无关的数据，方便数据的复用与管理，在本项目中，ScriptableObject 用于存储NPC 的调度数据以及行为参数，实现数据和逻辑的分离，提升系统的可维护性。  

# 2.2.3 相关算法介绍  

（1）A\*寻路算法  

A\*（A-Star）算法是一种广泛应用于游戏开发中路径规划的启发式搜索算法，其核心思想是结合贪心算法的速度和广度优先搜索的完备性并通过评估函数 $\scriptstyle { \mathrm { f } } ( { \mathrm { n } } ) = { \mathrm { g } } ( { \mathrm { n } } ) + { \mathrm { h } } ( { \mathrm { n } } )$ 选择搜索路径，这其中g(n)表示从起点到当前节点的实际代价， $\mathbf { h } ( \mathbf { n } )$ 表示从当前节点到目标的估计代价[12]。  

在本项目里，A\*算法的实现是围绕着多个关键模块来开展的，起初借助GridNodes类对游戏地图实施网格化处理，这样一来，整个空间就被划分成了一个个带有明确位置信息以及通行状态的节点，为路径计算提供了基础的数据结构，Node 类的核心在于，凭借定义比较方法来达成节点的优先排序机制，以此承担起节点评估的职责，它依赖于F 值来衡量每个节点的搜索优先级。在路径搜索方面，AStar 类负责执行核心的路径查找逻辑，它采用开放列表和关闭列表交替推进搜索过程，逐步接近目标节点并构建出最优路径，项目还对初步求得的路径做了平滑处理，来提升NPC 移动的自然度，运用路径后处理技术消除多余转折，让路径变得更加连贯，更符合真实的移动轨迹。A\*算法在本项目中的应用呈现出多方面优势：一方面，借助启发式函数能有效引导搜索方向，避免无效遍历，提升了整体效率，另一方面，算法有完备性，可保证在存在可行路径的情况下找到代价最小的解，并且还有良好的适应性，可依靠调整启发函数参数，灵活应对不同类型的地形与场景需求。  

基于实际开发需求，为了在游戏中实现高效快速寻径，以确保游戏的稳定和高效性，本项目还需要将对A\*算法进行针对性优化，这其中包括引入对角线移动以增强路径自由度、完善障碍物检测机制以提升路径的可行性与安全性，还要将实现路径缓存功能去减少重复计算，最终就能达到在保证寻路效果的同时显著提高了运行效率与NPC 的移动流畅性[13]。  

# （2）螺旋搜索算法  

螺旋搜索算法（Spiral Search Algorithm）是一种特殊的二维空间搜索策略，其搜索模式呈现出螺旋形状的轨迹[14]。在本项目中，将其适用于查找最近的可用位置或资源，螺旋搜索从中心点开始，按照螺旋状路径向外扩展搜索范围，基本搜索路径遵循以下模式：从中心点（ $( \mathrm { x 0 , y 0 } )$ ）开始，按照右 $$ 上 $$ 左 $$ 下的顺序移动，每完成两个方向后，搜索距离增加1 个单位，之后就重复此过程直到找到目标或达到最大搜索范围即可搜索完毕，结合NPC 系统以及 $\mathbf { A } ^ { * }$ 算法可以寻找可耕种的土地，并让其移动到目标地块获取地块。  

# （3）时间调度算法  

在这个项目当中，时间调度算法属于NPC 行为系统的核心组成部分，它的主要作用是依照游戏里的时间来动态安排NPC 去执行不同的任务，模拟出更加贴近现实情况的日常行为逻辑，该系统的设计覆盖了多个关键的实现环节，调度事件的数据结构是由SchedulDetails 类来定义的，它详细记录了每一项调度任务所需要的时间、位置以及行为等信息，可为后续的行为判断以及执行给予结构化的支持。项目运用SortedSet 数据结构对所有的调度事件进行排序以及管理，以此保证事件可按照预先设定好的时间顺序有序地执行，有效地保证了事件触发的时序性与一致性，在具体的执行层面，调度系统依靠监听游戏内时间变化的事件，在每一个关键的时间节点判断当前NPC 的状态，并且触发相应的行为切换逻辑。当调度事件触发的时候，系统会调用A\*算法，依据NPC 当前位置与目标地点之间的地图数据，实时生成一条最优的移动路径，引导NPC 自行前往任务地点，依靠这一整套机制的协同运作，NPC 可依据设定的日程在游戏世界里有序地移动并且进行行为转换，呈现出高度的行为规律性以及场景适应能力。这有效提高了游戏环境的沉浸感，还提升了游戏世界的活力与可信度，使玩家可感受到一个有节奏、有规律且充满生命力的虚拟世界。  

# （4）有限状态机系统  

有限状态机是一种用于描述对象在不同状态之间转移过程的模型，在计算机游戏人工智能中被广泛应用于角色行为的控制与管理，不仅能够表示静态的有限个“状态”，还能动态地表示状态之间的转移和动作等行为，有限状态机作为一种定性AI 技术，容易实现、理解、测试和调试，具有良好的通用性和扩展性，因而得到了广泛的应用[15]，因此本项目便采用Unity 引擎内置的Animator 系统实现NPC 的状态机机制，以系统化地组织和调度NPC 在不同情境下的行为模式，例如站立、行走、交互、工作等，该状态机系统主要由三个核心要素构成：其一是状态本身，用以定义NPC 在特定时间段内所表现出的具体行为，如静止待命或路径移动；其二是转换条件，即控制状态之间切换的逻辑判断依据，常见的触发条件包括游戏内时间变化、目标位置到达、与玩家的交互行为等；其三是参数系统，用于传递外部输入或内部变量，如移动方向、速度、任务状态等，从而为状态判断提供数据支撑。它通过将复杂的智能体的决策抽象为不同的状态以及状态之间的转换，让每个状态只需要管理自己的转换条件，从而降低智能体决策的整体复杂度，且由于其实现简单且逻辑结构清晰，因此NPC 能够实时感知自身状态与环境变化和自动完成状态间的动态切换就是靠有限状态机系统的支持，最终以达成实现行为的逻辑闭环与自然过渡的游戏效果[16]。也就是说，状态机的引入不仅显著提升了  

NPC 在游戏中的表现智能，也能使其行为更加连贯、真实，增强了玩家对虚拟角色的代入感与交互体验。这个技术还能结合前述的路径规划与时间调度系统，为实现智能化、多样化且具有生命力的非玩家角色提供了坚实的支撑平台[17]。  

# 第 3 章系统前期分析  

# 3.1 系统需求分析  

# 3.1.1 项目背景与目标  

随着游戏产业呈现出蓬勃发展的态势，玩家对于游戏内容所抱有的期望持续升高，各类游戏百花齐放，其中模拟经营游戏广受好评，受到了很多玩家的喜爱与支持，这说明模拟经营游戏经久不衰有着广泛的受众群体，同时NPC 系统作为模拟经营游戏的重要一环，针对非玩家角色也就是NPC 的行为智能性以及自然度方面的要求变得日益提高，在传统模拟经营游戏当中，NPC 大多时候呈现出机械化且有重复性的行为模式，缺失真实感与生命力，这种情况在相当程度上对游戏的沉浸体验造成了影响。  

此项目依托Unity 引擎打造一套2D 模拟经营游戏，对其进行开发并总结成较为容易实现的复用范式，并可以长期拓展其他丰富有趣的游戏功能，同时基于模拟经营游戏的大框架下，对NPC 人工智能系统结合当下热门技术进行研究学习，应用在实际场景中去完成一定的目标如借助A\*寻路算法与时间调度机制达成NPC 的智能移动、自然行为以及环境交互，所以该系统也拥有以下核心目标：其一，达成高效且准确的NPC 寻路功能，让NPC 在复杂环境里可智能避开障碍物并寻得最优路径，其二，构建基于游戏内时间的NPC 行为调度系统，使NPC 依据时间执行不同任务，呈现生活规律，其三，设计自然且流畅的NPC 动画切换以及状态转换，提升视觉体验，其四，优化系统性能，保证在多个NPC 同时活动时，维持良好的游戏运行效率。  

# 3.1.2 用户分析  

本系统的主要用户群体包含以下几类：其一，独立游戏开发者，这类开发者缺乏大型团队的支持，故而需要一套易于集成且轻量高效的NPC 系统，以此来提升游戏品质，其二，中小型游戏工作室，它们需要快速达成NPC 的智能行为，缩短开发周期，并且要保证游戏性能以及玩家体验。其三，游戏设计学习者，他们期望借助学习以及使用本系统，去了解游戏AI 的实现原理与方法，其四，最终玩家，尽管最终玩家并不直接使用本系统，然而作为最终受益者，其游戏体验会直接受到系统质量的影响。  

# 3.2 系统功能需求分析  

# 3.2.1 A\*寻路系统  

A\*寻路系统作为NPC 智能移动的核心功能，在本项目里肩负着生成最优路径并引导角色高效移动的关键要点，为契合复杂游戏环境下的实际需求，在系统设计时围绕地图表示、路径规划、多场景支持以及性能优化等方面做了全面考量与实现。  

在地图表示方面，系统凭借把游戏场景划分成网格节点的办法构建导航空间，每个节点带有位置信息及其通行状态，以此为路径计算提供基础条件。为适应多样化的游戏地形，网格系统支持多种地形类型的定义与识别，像普通地面、障碍物以及有特殊规则的区域，并且有动态更新能力，可实时响应游戏世界中地形变化或事件触发带来的导航需求调整，在路径规划层面，系统运用标准A\*算法实现从起点到目标点的最优路径搜索，结合对角线移动支持，有效避免“L 型”路径产生的生硬转向问题。借助路径平滑处理机制优化移动轨迹，让NPC 行为更自然流畅。  

针对多场景游戏的开发需求，本系统支持NPC 在不同场景间自由移动，还可以跨越场景边界进行路径连续规划，借助对各场景独立网格信息的维护与切换，达成路径逻辑上的无缝衔接，为提升整体性能与运行效率，系统引入路径缓存机制，避免对相同路径的重复计算，还提供寻路计算优先级设置功能，保证在资源有限时依然能保障关键NPC 的路径更新。  

另外，系统还实现了路径重规划能力，能在环境动态变化如出现新障碍物时实时调整原路径，保证NPC 始终能适应当前的导航条件并顺利完成任务，总体来说，该寻路系统构建了稳定高效的路径导航基础，也为NPC 在复杂游戏环境中呈现灵活、自主的移动行为提供了坚实支撑。  

# 3.2.2 NPC 行为调度系统  

行为调度系统于本项目里承担着统筹NPC 日常活动以及任务执行的关键作用，其主要以便依照游戏世界的时间进程和动态事件，灵活且高效地管理NPC 的行为安排，以此达成更为真实且富有节奏感的角色呈现，此系统首先构建于精细化的时间调度机制之上，可依据游戏内的时间单位精确触发NPC 的行为变更，支持按照日常周期、季节变化以及特定日期来制定调度计划，保证NPC 行为契合游戏世界的时间逻辑与生活节奏。为应对多重行为安排可能引发的时间冲突，系统引入了调度优先级机制，凭借比较任务关键性自动进行排序与协调，保证关键行为优先执行，在行为定义层面，系统允许为每个NPC 制定个性化的行为计划，清晰规定行为发生的时间段、具体地点以及预期动作，实现NPC 间存在差异的生活轨迹与行为风格。调度规则中还支持设置行为触发条件，使行为受时间驱动，也可结合环境状态与内部逻辑灵活激活，在动态交互方面，系统拥有强大的事件响应能力，可在游戏事件发生时主动调整行为安排，支持临时中断当前任务以响应更高优先级的活动，在任务完成后，系统可智能恢复NPC 的原有行为轨迹，或者顺利切换至预定的下一项任务，保障行为流程的完整性与连贯性。借助这一行为调度系统，NPC 可呈现出对时间敏感、适应环境的智能行为，也极大提升了游戏世界的真实感、动态性与叙事驱动能力。  

# 3.2.3 NPC 动作控制系统  

动作控制系统作为NPC 视觉表现以及交互反馈的关键核心模块，它的设计目的在于借助精细的动画管理以及移动控制，去构建出拥有真实感且有响应性的角色行为展示，在动画状态管理这个方面，系统依据状态机机制达成对NPC 不同动作的统一控制逻辑，包含行走、站立、工作等基础行为状态，并且凭借设置动画参数比如速度、方向、触发标志等达成各状态之间的平滑过渡，防止动画切换过程里出现突兀和不连贯的情况，以此提升整体表现的自然程度和可视体验。  

在移动控制层面上，系统运用基于物理的移动模型，达成NPC 在游戏世界里的真实位移，支持不同速度等级以及方向控制，同时集成了碰撞检测和避障逻辑，保证NPC在复杂环境中可自主避开障碍物并完成路径导航任务，配合路径规划系统达成高质量的移动执行，为了提高NPC 与玩家的视觉交互，系统还给出多种视觉反馈机制：按照当前移动方向自动切换角色朝向，让角色始终面向行进目标，提升运动表现的一致性，在特定状态下触发相应的视觉特效，像工作动画的工具闪光、交互时的提示动画等，丰富NPC 行为的表现力，另外还配置有状态指示器，用来实时展示NPC 的当前行为状态，使玩家可直观获取角色信息，提升交互效率和沉浸感。依靠动作控制系统的全面支持，NPC 在逻辑上拥有智能行为决策能力，也在视觉层面达成了生动、自然且高度响应的动态表现，强化了虚拟角色在游戏世界中的生命感和真实感。  

# 3.2.4 场景交互系统  

场景交互系统作为实现NPC与游戏世界深层互动的关键模块，其作用在于给予NPC感知环境、操作对象以及与其他角色交流的能力，提高虚拟世界的动态性与沉浸感，此系统主要包含三大交互维度，分别是对象交互、角色间交互以及玩家交互。  

在对象交互层面，系统准许NPC 与各类场景物体开展功能性互动，像使用工具、拾取道具这类操作行为。每一次交互都配有相应的动画和特效展示，以此提升视觉表现的真实感，并且还可以对环境状态产生影响，比如改变物体位置或者触发事件，改变游戏内的环境。  

在NPC 间交互方面，系统提供基础的社交行为模拟，让多个NPC 之间可进行交流与协作，如打招呼、共同完成工作任务等，提高NPC 的行为丰富性与社会性。系统还实现了简单的对话机制，使得NPC 可依据预设逻辑与脚本进行基础的信息交换与行为响应。  

在玩家交互方面，系统支持玩家与NPC 之间进行自然的对话与互动，包括任务的接取、执行与完成流程，也让NPC 可对玩家的行为做出反应，例如根据玩家完成任务的表现调整态度或者提供不同的反馈。借助这一系列机制的有机融合，场景交互系统实现了NPC 与环境、NPC 之间以及NPC 与玩家的多层次互动，还极大地提升了游戏世界的可交互性与角色的行为表现力，为构建一个有逻辑性、参与性和沉浸感的虚拟生态系统提供了有力支撑。  

# 3.3 非功能性需求分析  

# 3.3.1 性能需求  

为确保系统性能正常，需要遵循图3.1 指标需求。  

表 3.1 性能需求表  


<html><body><table><tr><td>性能指标</td><td>具体要求</td></tr><tr><td>计算效率</td><td>A*寻路算法在中等复杂度场景中计算单条路径时间不超过15毫秒; 多NPC同时活动时，每帧AI计算时间总和不超过5毫秒； 内存占用合理，避免频繁的垃圾回收;</td></tr><tr><td>渲染性能</td><td>NPC动画切换流畅，无明显卡顿 在中等配置设备上，支持5个以上NPC同时活动而保持稳定帧率</td></tr><tr><td>资源管理</td><td>设计合理的资源加载与卸载机制 优化场景切换时的资源处理 避免内存泄漏和资源浪费</td></tr></table></body></html>  

# 3.3.2 可用性需求  

为确保系统易于使用和维护，需要遵循表3.2 设计需求。  

表 3.2 设计需求表  


<html><body><table><tr><td>设计方面</td><td>具体措施</td></tr><tr><td>接口设计</td><td>提供清晰、一致的API设计 遵循Unity组件式架构，便于集成 文档完善，包含使用示例和最佳实践</td></tr><tr><td>配置灵活性</td><td>支持通过编辑器界面配置NPC行为和参数 提供 ScriptableObject数据存储，方便非程序人员编辑 允许运行时动态调整AI参数</td></tr></table></body></html>  

<html><body><table><tr><td>设计方面</td><td>具体措施</td></tr><tr><td rowspan="3">错误处理</td><td>提供完善的错误检测和处理机制</td></tr><tr><td>在开发模式下提供详细日志和调试信息</td></tr><tr><td>异常情况下保证系统稳定性，避免崩溃</td></tr></table></body></html>  

# 3.3.3 可扩展性需求  

为适应游戏开发的迭代特性，需要遵循表3.3 拓展需求。  

表 3.3 拓展需求表  


<html><body><table><tr><td>设计方面 具体措施</td><td></td></tr><tr><td>模块化设 采用高内聚、低耦合的设计原则各子系统间通过接口通信，降低依赖支持组件的独立开发 计 和测试</td><td></td></tr><tr><td>行为扩展</td><td>提供行为定制的框架，便于添加新的NPC 行为；支持寻路算法的替换或优化；允许整合 第三方AI解决方案</td></tr><tr><td>平台兼容 性能限制</td><td>确保在Unity支持的主流平台上正常运行；适应不同分辨率和屏幕尺寸；考虑移动平台的</td></tr></table></body></html>  

# 3.3.4 可测试性需求  

为方便后期测试快速定位软件漏洞缺陷，测试需要根据表3.4 进行。  

表 3.4 测试需求表  


<html><body><table><tr><td>测试类型</td><td>具体措施</td></tr><tr><td>单元测试</td><td>核心算法设计为可测试结构; 支持自动化测试;</td></tr><tr><td>集成测试</td><td>提供测试用例和基准测试 设计测试场景，验证系统整体功能 提供性能分析工具，监测系统运行状态 支持回归测试，确保更新不破坏现有功能</td></tr></table></body></html>  

# 3.4 系统可行性分析  

# 3.4.1 技术可行性  

本项目的开发建立在多个成熟技术基础之上，具有良好的可行性与实施条件。  

作为开发的主力引擎Unity 作为广泛应用于游戏开发领域的成熟平台，提供了全面的2D 游戏开发支持，包括完备的物理系统、动画系统和高度可扩展的脚本编程环境。结合C#语言的高效执行性能和面向对象特性，为构建复杂的AI 行为系统提供了坚实的技术基础，而且Unity 拥有庞大的开发者社区，提供了丰富的教程、插件和参考案例可以进行参考，大大有利于加快开发进度与问题解决效率。  

在算法层面而言，本项目所依赖的核心技术如A\*路径搜索算法、有限状态机模型以及基于时间的行为调度系统均为游戏制作AI 领域中被广泛验证的通用方法。其中，  

A\*算法原理清晰、可扩展性强，可以去适用于多种路径规划需求；状态机结构在行为控制中拥有清晰的逻辑表达能力与较低的实现成本；而时间调度机制则可借助Unity 的事件系统去进行实现，不需要依赖其他插件可以避免导致可能潜在的版本或者依赖冲突问题。  

本项目前前期已完成关键功能的原型验证，通过Demo 测试和拆解功能局部得到可行的结果，初步能够验证出系统的可行性与有效性，而且对于项目中可能遇到的技术挑战已进行识别与分析，通过相关技术社区也一并制定了相应的技术应对策略。综合以上因素，本项目在平台支持、技术选型和开发能力方面均具备较高的开发可行性，可以进行设计研究。  

# 3.4.2 经济可行性  

从开发成本和潜在价值来看，项目具有良好的经济可行性：在开发成本方面，首先开发环境基于免费的Unity 个人版本，无需额外软件许可费用，且开发周期合理，可根据优先级分阶段实现功能。  

项目对资源需求适中，不需要大量美术和音效资源，少量需要通过Aseprite 工具进行会话，其他主要可以通过Unity 商店进行购买。  

# 3.4.3 操作可行性  

系统的实际应用应该具有良好的操作可行性，在开发过程中应该注意相关维度以方便快速开发和修改，详细可见表3.5。  

表 3.5 操作可行性表  


<html><body><table><tr><td>维度</td><td>具体特点</td></tr><tr><td>易用性</td><td>采用组件化设计，使用者可通过Unity编辑器直观配置 提供详细文档和使用示例，降低学习成本 遵循Unity 常用设计模式，对Unity开发者友好</td></tr><tr><td>维护性</td><td>清晰的代码结构和注释，便于后续维护 模块化设计使问题定位和修复更加容易 版本控制支持，便于追踪变更和协作开发</td></tr><tr><td>适应性</td><td>系统参数可调整，适应不同类型的2D游戏 可根据项目需求裁剪功能，灵活集成 支持后续功能扩展和性能优化</td></tr></table></body></html>  

# 3.4.4 总体可行性评估  

综合分析技术、经济和操作三个方面，本项目具有较高的可行性：  

（1）技术路线清晰，核心功能已有成功案例验证  

（2）开发成本可控，潜在价值可观  

（3）系统设计注重易用性和可维护性，降低应用门槛  

因此，本项目在合理的资源投入和开发周期内，能够实现预期目标，开发出一套实用、高效的NPC 人工智能系统，满足2D 游戏开发的需求。  

# 第 4 章系统设计与实现  

# 4.1 模拟经营游戏开发平台与工具  

模拟经营类游戏属于那种着重突出玩家管理以及决策能力的游戏类别，它对游戏系统所有的复杂性和交互性提出了比较高的要求，此项目把Unity 当作核心开发引擎，再搭配多种辅助工具，搭建起了一套完整的开发环境，Unity 引擎依靠自身强大的跨平台能力、丰富的资源库以及活跃的社区支持，给本项目的开发奠定了坚实的基础。Unity的组件化设计理念以及可视化编辑器极大地简化了游戏开发流程，让开发者可把更多精力放在游戏逻辑和体验优化上面，而非底层技术实现方面。  

在开发环境这块，本项目选用Visual Studio 2022 作为主要的代码编辑器以及调试工具，Visual Studio 与Unity 的深度整合提供了代码智能提示、实时错误检查以及断点调试等功能，可提高开发效率。项目版本控制采用Git 系统，凭借创建功能分支以及定期合并的工作流程，可保证在中后期代码比较庞杂的情况下游戏开发顺利进行以及代码质量稳定。  

本项目还运用了 Unity Asset Store 里的多个辅助插件，像 Tilemap Extras 用于高级地图编辑，SuperTiled2Unity 用于导入 Tiled 地图编辑器创建的地图资源，以及 DoTween动画库用于实现流畅的UI 动效，这些工具的引入极大地丰富了游戏表现力并且简化了特定功能的实现难度。  

在美术资源方面，本项目采用像素风格的美术设计，利用Aseprite 进行像素风格的角色设计以及动画制作，同时应用从Unity 商店购买的素材，像素风格的选择一方面契合模拟经营游戏的传统美学风格，另一方面也优化了开发效率以及游戏性能，音效和背景音乐则采用FMOD 音频中间件进行管理以及触发，这种方式让音频系统与游戏逻辑解耦，便于后期调整以及优化。总体而言，本项目的开发平台和工具选择考虑了开发效率，也兼顾了最终产品的质量以及性能表现，为游戏开发提供了全面的技术支持。  

# 4.2 模拟经营游戏开发过程  

模拟经营游戏的开发是个逐步推进、持续迭代的进程，本项目依照游戏开发的关键原则，把开发进程划分成概念设计、原型开发、核心功能实现、内容丰富以及优化润色这五个主要阶段，在概念设计阶段，借助调研市面上现有的游戏以及社区内容，确定了以农场经营作为主题的游戏核心玩法，并且绘制了初步的游戏流程图以及功能规划。此阶段的重点在于明确游戏的核心循环以及玩家动机，为后续开发筑牢了坚实的设计根基，概念设计完成后便开启原型开发，在较短时间内达成了角色移动、简单的物品交互以及时间系统等基础功能，借助这些最小可行产品验证了核心玩法的可行性与趣味性，进入核心功能实现阶段后，开发工作分成多条并行的开发线路：一方面达成了基于A 算法的NPC 寻路系统，让NPC 可在游戏世界里智能地移动，另一方面开发了时间调度系统，控制游戏内日夜更替以及季节变化，以及NPC 的行为模式，同时还构建了地块管理系统，实现了耕种、浇水、收获等农场核心玩法。此阶段的重点是保证各系统间协同工作，比如保证NPC 的行为调度可准确地触发寻路系统，使NPC 在指定时间抵达指定位置执行预设任务，在内容丰富阶段，拓展了游戏的内容深度，增添了多种作物类型、NPC 对话系统等内容，这些内容的加入极大地提高了游戏的可玩性与回访价值。  

最后的优化润色阶段主要聚焦于游戏的性能优化以及用户体验改进，囊括优化资源加载策略、改进UI 响应速度等工作，  

整个开发过程采用了敏捷开发方法，每两周开展一次迭代，每次迭代结束后进行测试和评审，依据反馈调整下一阶段的开发计划，这种迭代方式使项目可及时发现并解决问题，避免了开发后期的大规模重构。同时凭借测试确定改进方向，最终打造出一款有技术深度又有良好用户体验的模拟经营游戏。  

# 4.3 模拟经营游戏功能的设计与实现  

# 4.3.1 游戏整体设计流程图  

本项目的游戏设计遵循系统化的思路，建立了清晰的功能架构和流程，先从分析游戏基础流程入手，图4.1 所示的游戏整体流程图概括了新游戏初始化、存档加载、主游戏循环的进入，以及通过游戏菜单进行的保存、加载和退出等关键路径，以确保整个游戏流程的完整性。  

![](images/058d521f07a4b43e10cc3030fcaca6aac4cc710ccbb694ee0998322239f2430c.jpg)  
图 4.1 游戏主流程架构图  

核心玩法作为游戏的核心重点，作为模拟经营游戏，就需要考虑从玩家互动性和游戏玩法长期发展性入手，聚焦游戏的核心玩法循环。通过图4.2 可见，玩家在体验游戏的过程中的输入如何驱动游戏内的主要子系统进行响应和交互，这其中包括角色移动、与NPC 对话、库存管理、作物种植等核心功能模块之间的数据流和控制流，以及它们如何共同影响游戏世界状态并通过UI 反馈给玩家。  

![](images/26bfd675e9b18fc11f3e5d7157beedb75a2e98652e260856edfcc353f976fe50.jpg)  
图 4.2 核心玩法循环与主要子系统交互模型图  

游戏的主要交互流程是先从玩家输入开始，通过UI 系统转发到相应的功能系统进行处理，处理结果会更新游戏状态并通过前端展示层反馈给玩家。例如在实现耕种这一功能中，考虑到当玩家选择耕种一块土地时，输入首先被UI 系统捕获，这时候就应该转发到角色控制系统使玩家角色移动到目标位置，触发农场管理系统执行耕种操作，操作结果会更新地块状态，并通过动画和声音系统给予玩家视听反馈。这一过程优先选择响应链条的设计模式可以在一定程度可以去确保了游戏的自然流畅，及时反馈感强，也方便开发过程中排查异常定位问题。  

在游戏事件流转层面，项目采用观察者模式和事件总线机制，减少系统间的直接耦合，方便后期模块拓展开发。例如图4.3 所演示对时间系统的构建过程中，特别关注了时间系统会广播时间变化事件，然后在NPC 系统和农场管理系统等有关时间的内容中去订阅这些事件，并根据时间变化调整其中行为和状态。这种松耦合的设计在一定程度上使得系统扩展变得简单，后期如果有新功能的添加不会影响现有系统的稳定性。  

![](images/60a39c82d0f5139b14f38a3fd9c4f0939eccdc8b13a614541b3b4e469a843c04.jpg)  
图 4.3 后台系统驱动与游戏世界动态演化图  

整体而言，游戏的设计流程充分考虑了模块化、可扩展性和性能优化，为实现一个复杂而流畅的模拟经营游戏提供了坚实的架构基础。  

# 4.3.2 游戏开始界面与开场动画设计与实现  

游戏的开始界面和开场动画是玩家接触游戏的第一印象，对建立游戏氛围和引导玩家进入游戏世界至关重要，所以在开始界面和开场动画的设计与实现过程中，既要满足游戏的叙事需求，又要兼顾技术性能和用户体验，为玩家进入游戏世界提供了良好的铺垫和引导。  

本项目的开始界面采用了简洁的设计展现了游戏的核心主题和美术风格。如图4.4界面中央是游戏标题和主菜单按钮，包括“新游戏”、“继续游戏”、“设置”和“退出”四个主要选项。这些 UI 元素的实现基于 Unity 的 UI 系统，利用 Canvas 和 RectTransform 组件进行布局，在Canvas 下添加 Panel 显示文字和按钮元素，同时为了提高资源重用和一致性，实现按需加载和性能优化，在开始界面UI 的Canvas 中采用动态化实例UI 元素，使用预制体Prefab 配置好菜单的 Panel（包含所有子元素、组件、布局和样式），通过Instantiate()方法创建Panel 的一个实例，这样使得项目UI 开发更加灵活、可维护。  

![](images/2cc27e3ba17d784bcbe13f9314df800f920e96407103a1390b3832e98508e953.jpg)  
图 4.4 开始界面  

开场动画主要是向玩家介绍游戏背景故事，动画的实现采用了Timeline 系统，这种工具能够将开场动画顺序以及音乐和人物控制结合起来。为了提高用户体验，开场动画设计了可跳过机制，玩家可以通过点击任意位置或按下特定按键直接进入游戏，而且系统会记住玩家是否已经观看过开场动画，对于读取旧存档后会自动跳过这一环节，减少重复操作带来的疲劳感。开场动画和动画制作可见图4.5 和图4.6。  

![](images/548912767ab5b67ac73a8bd186ed2acb506461065e7aa17f35e7ee60a141ded5.jpg)  

![](images/ffd87df729258df38ef7f010377367165fab232472612b064248117fa8ed224e.jpg)  
图 4.5 开场动画  
图 4.6 开场动画制作  

# 4.3.3 游戏角色控制设计与实现  

角色控制系统是玩家与游戏世界互动的核心媒介，其设计会直接决定了玩家的游戏方式，比如FPS 游戏中操作角色是键盘操作移动和鼠标射击，MOBA 游戏中操作角色是通过鼠标点击移动和键盘操作释放技能，本质上是状态和行为的执行、切换和衔接，但这个过程需要符合现实世界的直觉逻辑，需要在实现角色控制系统整合物理反馈、动画表现与游戏逻辑，才能提供精准、响应迅速且富有表现力的操作体验。  

由此分析，本项目决定采用状态机管理角色的不同状态以实现流畅自然的角色移动和交互，角色控制逻辑的思考和实现可见图4.7。  

![](images/d09a9ee2cc7bedf95cfdff8f374870576c5c44433f25d0564492d679ba83e2cd.jpg)  
图 4.7 角色逻辑控制图  

首先项目先实现基本的角色行为控制，它附着于玩家游戏对象（GameObject）之上的核心脚本Player.cs 驱动，核心代码参照图4.8 和图4.9，该脚本统筹了管理玩家的输入响应、物理移动和动画状态物理层面的交互依赖于Unity 引擎的Rigidbody2D 组件，可以通过该组件为玩家控制角色提供在2D 游戏世界进行碰撞检测和基础物理响应反馈的基础，在 Player.cs 中通过标准的输入接口 Input.GetAxisRaw("Horizontal")与 Input.GetAxisRaw("Vertical")实时捕获玩家的键盘控制的原始输入，通过处理形成一个二维向量MovementInput 去表示移动方向和强度。本项目还内置对角线移动速度修正机制：当角色同时接收到水平与垂直方向的输入指令时，两个方向的输入值均会乘以一个固定的系数（0.6f），有效避免了斜向移动时速度超出单轴移动速度的问题。如果玩家若按下KeyCode.  

LeftShift 键，输入值将进一步乘以 0.5f，角色随之切换至更为谨慎的慢走姿态，这一点参照了现在常见的游戏模式按键，方便玩家快速入门上手。  

![](images/188d98ebcabad40ee5b38b299a1078d103b762fc8be7494f376ec3c9639d466c.jpg)  

![](images/4e562240d5a2b3719289b084aa5056afde3baaaee622678c5a550a3fec0698b3.jpg)  
图 4.8 Player 核心代码伪代码展示  
图 4.9 Player 核心代码伪代码展示  

控制伴随着动画的展现才能给玩家更加直观的反馈，通过Animator 组件及其状态机可以轻松实现。Player.cs 脚本获取到角色模型子层级下的所有 Animator 组件可以允许对角色不同部位或附属物件（如工具）进行统一或独立的动画控制。核心方法是SwitchAnimator()，依据角色当前的布尔状态 isMoving（指示是否正在移动）以及归一化后的输入向量InputX、InputY（指示移动方向）来动态调整Animator 控制器中的同名参数，值得一提的是，鼠标在世界空间中的位置也被用于动画控制。脚本中的变量mouseX 与mouseY 记录了鼠标相对于角色的朝向这样的操作能够使得角色能够流畅地在站立、行走以及不同方向的行走动画之间切换。  

鼠标的作用不仅仅是引导视觉焦点，更是玩家与游戏世界互动的关键纽带。如果此时玩家没有持有某类消耗品或场景布置道具，那么一次简单的点击操作，就会触发工具的使用或一系列特定的交互流程。如图4.10 通过鼠标点击就可以与箱子进行互动。  

![](images/3128dee016b1dbef605379e886ac1650749ea9f20321c05df6d014c557f271bd.jpg)  
图 4.10 与箱子进行互动展示  

这个鼠标点击过程也较为轻松实现：系统首先计算鼠标点击位置相对于玩家的方位，并将其简化为上、下、左、右四个主要方向，之后将启动一个名为UseToolRoutine的协程来管理整个交互过程，在此协程中玩家的输入会被暂时禁用，角色的Animator会接收到useTool 触发指令以及计算好的朝向参数，播放相应的工具使用动画，播放到特定帧或经过预设时间后，系统会通过EventHandler 中的自定义事件回调执行工具或交互的实际效果，例如在农田中播种、与NPC 对话、开箱子等，等待动作完成后玩家的输入控制权随即恢复。  

为应对游戏过程里复杂的场景切换、UI 交互以及特殊技能施放等状况，角色控制系统集成了一套精细的输入状态管理机制，该机制主要依据变量的变化情况来进行判断，例如布尔变量inputDisable 起着总开关的作用：在场景加载过渡阶段、游戏处于暂停状态时，或者角色执行特定耗时动作期间，此变量会被设置为true，暂时屏蔽玩家的常规移动输入，类似地，useTool 状态专门用于标记工具使用阶段，防止操作冲突。  

在协程的核心阶段，为使动作显得更为连贯且执行更为合理，角色的常规移动输入会借助布尔变量 inputDisable 暂时给予关闭，此时角色的 Animator 组件会接收到 useTool 动画触发指令以及刚计算得出的朝向信息，播放相应的工具使用动画，当动画播放至指定关键帧，或者经过短暂延迟后，系统会凭借全局事件 EventHandler. CallExecuteActionAfterAnimation 触发实际的互动逻辑，比如可能是在田地里进行播种，或者是与一位NPC 展开对话。待整个交互过程结束，系统会立即恢复玩家的输入控制，如此设计保证了动画表现与游戏行为之间有较高的同步性，能让玩家的每一次操作都获得及时且明确的反馈。  

# 4.3.4 游戏地图系统设计与实现  

地图系统作为模拟经营游戏的基础架构，承担着玩家的全部活动以及游戏的主要内容，在本项目当中，设计了一套有多层次且高度交互特点的地图系统，该系统结合了Unity 的Tilemap 系统以及自定义的地块管理逻辑，达成了丰富多变的游戏环境，地图系统的核心架构主要分为三个层次，分别是视觉表现层、物理碰撞层以及功能数据层。视觉表现层的作用是负责地图的视觉呈现，从图4.11 可看出，项目运用多个Tilemap 组件分别对地面、水体、装饰物等不同类型的图块进行渲染，物理碰撞层处理角色和NPC与环境之间的物理交互，明确了可通行区域以及障碍物，功能数据层用于存储每个地块的属性和状态，像土壤湿度、肥力、当前种植的作物等信息，这些数据与游戏的核心玩法直接相关联。  

![](images/3a7ad7770b2f0666ac974a8dac2f7ed7bc1c1fac2ab379a72c35e5e901b16b7f.jpg)  
图 4.11 Tilemap 分层  

于地图创建工作而言，该项目运用了混合设计方式，其中基础地形借助手工设计来达成游戏体验的精准把控，地图数据借助ScriptableObject 给予管理，每一个场景都对应着一个地图数据对象，此对象覆盖基础地形信息以及动态地块状态，这样的数据结构设计可让地图信息便捷地实现序列化与反序列化，以支撑游戏存档及加载功能。  

地块交互系统属于地图系统的关键功能之一，其明确了玩家与地图里不同区域的互动方式，系统核心代码如图4.12 所示，借助网格化的交互模型，当玩家运用工具时，系统会先判定目标地块位置，接着依据工具类型以及地块当前状态来计算交互结果，举例来讲，运用锄头工具作用于草地地块会使其转变为耕地，而对已然是耕地的地块使用该工具则会刷新其状态。每一种工具与地块的组合都有预定义的交互规则，这些规则依靠可配置的数据表进行管理，方便后续调整与扩展，交互过程中会引发相应的视觉以及音效反馈，如地块外观改变、粒子效果以及相应的工具使用音效，这些反馈提升了玩家的契合感以及游戏的沉浸感。  

![](images/f203fcd36db5e8d1e14a34d3370a6f33f4ac8d175762ef85d9b87acb6d4551be.jpg)  
图 4.12 地块上物品交互核心代码  

季节变化体系属于地图呈现中另一关键要点，该游戏内部设置了春、夏、秋、冬这四个季节，其中每个季节都有独特的视觉风格以及游戏规则，季节的变换会对游戏玩法产生直接影响，像是不同季节适宜种植的作物种类便有所不同。  

地图系统达成了区域管理的功能，它把地图划分成多个功能区域，例如农场区、森林区、村庄区等，每个区域有着其特定的资源分布状况以及交互规则。借助区域信息运用自定义的碰撞检测系统来实施管理，当玩家角色进入特定区域的时候，系统会依据实际需求加载或者激活相应的游戏内容，并且有可能触发特定的游戏事件，具体的实现方式可见图4.13，这种区域化的设计也可优化性能，依靠动态地加载和卸载区域内容来控制内存的使用。  

![](images/384844532ae64e06b6311f37e9b7b55574d24e2fe15e16706642fdfeb5b0b87b.jpg)  
图 4.13 区域跳转检测核心代码  

游戏地图系统的设计与实现充分运用Unity 引擎技术优势，结合项目特定需求，打造出一个兼具美观与丰富功能的游戏环境，该系统采用模块化设计和数据驱动架构，有较高可扩展性与可维护性，为游戏长期发展奠定坚实基础，借助精心设计的地图交互机制及视觉表现，系统成功把模拟经营游戏核心玩法具象化，给玩家带来沉浸式游戏体验。  

# 4.3.5 游戏背包系统设计与实现  

背包系统作为玩家与游戏物品交互的核心枢纽，需要分离好数据层与表现层，具体可见下图4.14。  

![](images/ebbb73b951af1b7bf9ef59eed358ed279d78b975c7ef9aab2a075cd39e03e946.jpg)  
图 4.14 背包系统类图  

在数据方面，系统借助ItemDataList_SO 类对所有物品的静态属性配置给予集中管理，该类是从ScriptableObject 继承而来，如此一来策划人员可在Unity 编辑器里直观地配置以及调整各类物品参数，而不用去修改代码，背包的具体物品实例由  

InventoryManager 单例进行统一管理，采用 List<InventoryItem>这种数据结构来存储玩家背包数据，并且利用索引位置迅速定位特定物品。虽说没有直接运用Dictionary 结构，不过系统凭借高效的遍历查找达成了近似O(1)的查询性能，保证了物品的添加、移除以及交换过程高效且简洁。  

物品交换机制堪称系统的一个突出亮点，SwapItem 方法巧妙地处理了不同背包位置间的物品互换情况，当玩家于背包内拖动物品时，系统可自动识别拖拽的起始点以及目标位置，依据槽位状态执行相应操作：要是目标槽位已然存有物品，便执行直接交换，要是目标为空槽，就进行简单移动并清空原槽位。系统还达成了跨背包拖拽功能，准许玩家与商店、储物箱等其他容器开展物品交互，借助位置参数判断执行各异的业务逻辑，系统的跨背包交换方法里还实现了同类物品的自动堆叠功能：当目标位置存在相同ID的物品时，会自动合并数量并清空原始位置，这样的设计契合用户直觉，又提升了背包空间利用率。  

在视图方面，背包系统运用了模块化的UI 设计思路，每个物品槽是由SlotUI 类进行管理的，该类承担着物品图标、数量文本的渲染工作以及各类交互事件的处理任务，UpdateSlot 方法精准把控着物品数据发生变化时UI 的更新情况，涉及了图标显示、数量文本以及交互状态的调整。对于空的槽位，系统会将图像组件禁用并且把数量文本清空，以此保证视觉上的清晰程度，而对于放置了物品的槽位，就会展示相应的图标以及精确的数量，同时启用交互功能，这样精细的状态管理，让背包界面在任何操作之后都可维持视觉上的一致性以及逻辑上的准确性，  

背包系统的交互体验借助一系列精心设计的拖放机制得以强化。SlotUI 类实现了Unity 的多个接口，像是 IPointerClickHandler、IBeginDragHandler、IDragHandler 和IEndDragHandler，构建起完整的拖拽事件链，当玩家开始进行拖拽操作时，OnBeginDrag方法会激活一个跟随鼠标移动的物品图像，在拖拽的过程当中，OnDrag 方法可保证这个图像实时跟随鼠标的位置，为玩家给予明确的视觉反馈，当拖拽结束时，OnEndDrag方法会检测目标位置，并依据拖拽终点的类型触发相应的业务逻辑，比如背包内物品的交换、商店的购买或者出售等。这一设计支持背包内物品的重新排列，还达成了与游戏其他系统的无缝对接。  

下图4.15 直观地呈现出背包界面经过了精心的设计，物品格子被整齐地排列着，每一个格子都清楚地呈现出对应物品的图标以及数量，用户可依靠拖拽的操作方式轻松地整理物品，系统会自动处理同类物品的堆叠与分离，极大地提升了背包管理方面的便捷程度以及直观感受，界面的布局充分考虑了视觉平衡以及操作的便利性，槽位的大小恰到好处，可清晰地展示物品的细节，又不会占据过多的屏幕空间。  

![](images/d09cfed73dcc42b046779574ba46354f36aa0da444c8092a63e1f8bf0e4c027c.jpg)  
图 4.15 背包系统展示  

# 4.3.6 游戏时间系统设计与实现  

时间系统作为模拟经营游戏的核心机制，通过精确的时间流逝控制和丰富的时间事件，成功构建了游戏世界的时序变化和季节轮转。系统的设计以真实世界时间比例的抽象和加速为基础，既保留了时间流逝的真实感，又避免了玩家在等待中产生的无聊感。TimeManager 作为系统的核心组件，采用单例模式全局管理游戏时间状态，通过精心设计的数据结构和事件机制，实现了高度可定制的时间流逝控制。  

在数据模型设计上，系统构建了一套完整的游戏内时间表示法，包括秒、分、时、日、月和季节等层级单位，而且为了方便各子系统进行时间计算和比较，GameTime 属性通过TimeSpan 对象提供了对时间单位的统一封装：  

public TimeSpan GameTime $\Rightarrow$ new TimeSpan(gameHour, gameMinute, gameSecond);   
[SerializeField] private Season gameSeason;   
[SerializeField] private int gameDay;   
[SerializeField] private int gameMonth;   
[SerializeField] private int gameHour;   
[SerializeField] private int gameMinute;   
[SerializeField] private int gameSecond;  

季节系统借助Season 枚举类型达成，把一年划分成春、夏、秋、冬四个季节，每个季节有着固定天数以及独特的游戏规则，这样的时间模型设计能体现现实世界的时间概念，又兼顾了游戏玩法的需求，在真实性与游戏性之间达成了不错的平衡，  

时间推进的核心逻辑依靠Unity 的Update 方法来实现，运用了层层递进的时间单位更新机制。系统先是累积deltaTime 获取真实的时间流逝，当累积值超过预设阈值时便触发一秒的游戏内时间推进，秒数达到60 时进位成为分钟，分钟达到60 时进位成为小时，依此类推完成小时、天数以及季节的更新，每个时间单位的变化都会触发相应的全局事件，像 GameMinuteEvent、GameHourEvent、GameDayEvent 和 GameSeasonEvent等，让其他系统可响应时间变化执行相应逻辑。这种事件驱动的设计将时间系统与其他系统解耦，各子系统只需关注自己所关心的时间粒度，极大地简化了系统间的交互复杂度，  

系统的一项创新是实现了多层次的时间控制机制，首先是游戏状态控制，当游戏进入暂停状态时，时间推进会自动停止，玩家返回游戏时再恢复原有速度。其次是时间流速控制，玩家可依靠界面按钮在预设的几种时间速率之间切换，例如1 倍速、5 倍速和10 倍速等，方便玩家依据实际需要调整游戏节奏，最后是日夜循环控制，系统会依据游戏内时间自动调整全局光照强度和色调，模拟一天中不同时段的光照效果，提高游戏的沉浸感以及视觉表现力。  

时间系统与其他游戏系统的联动十分出色，在作物生长方面，系统每天更新作物的生长天数并检查季节适应性，在NPC 行为方面，系统每分钟触发调度检查，决定NPC是否执行新的行程，在天气系统方面，根据季节和时间随机生成不同天气事件，在商店营业方面，根据时间控制商店的开放和关闭状态。这些联动机制让游戏世界呈现出一种有机的、动态变化的特性，大幅提高了游戏的真实感和生命力，  

时间信息的视觉呈现借助TimeUI 组件达成，TimeUI 组件可见图4.16，该组件在屏幕一角显示当前的时间、日期和季节信息，界面设计简洁明了，采用了符合游戏风格的像素字体和图标，保证信息清晰可辨同时不占用过多屏幕空间。时间流速的当前状态也会在界面上明确显示，便于玩家了解当前的游戏节奏，另外系统还实现了时间相关的过渡效果，如图4.17 日出日落时的逐渐光照变化，季节转换时的环境色调调整等细节可以增添游戏氛围感。  

![](images/59e314d7883ce7b88dc0031679776d73fd07c9de90a2e036e757802685a9ab4c.jpg)  

![](images/34cccad020666b038115b627c50b373b787f193163f3805167d057eafe36a068.jpg)  
图 4.16 TimeUI 组件展示  
图 4.17 时间变化后 UI 及环境变化展示  

时间系统在游戏开发中的设计与实现体现出精细的考量，它为游戏构建了基础的时间框架，还凭借丰富的事件机制以及视觉表现，成为连接各个游戏系统的核心纽带，为模拟经营游戏的深度与沉浸感奠定了坚实根基，系统有模块化架构与可配置特性，这为游戏的长期更新以及内容扩展提供了便利。未来可轻松添加节日活动、时间限定事件等丰富内容，提升游戏的可玩性以及生命周期。  

# 4.3.7 游戏种植系统设计与实现  

种植系统运用精心设计的数据结构以及状态控制手段，成功地对作物从播种直至收获的整个生命周期给予模拟，该系统的核心要点在于基于时间推进的生长状态管理以及细致入微的视觉表现转换，在设计理念方面，系统把“种子”以及“处于生长过程中的作物”看作是两个彼此独立却又存在关联的概念。种子归属于物品系统的一部分，而一旦被种下，便会转变为场景里由Crop 类进行管理的动态实体，这种转变借助CropManager 类的OnPlantSeedEvent 方法来达成，此方法在捕捉到种植事件之后，会对相应地块的 tileDetails 数据加以更新，记录种子 ID 以及生长天数，并且调用 DisplayCropPlant 方法在场景中生成对应的作物实体。  

作物数据结构的设计是该系统的基础所在，CropDetails 类借助多组数组定义了作物生长的一整套完整参数集，growthDays 数组记录各个生长阶段所需要的天数，growsPrefabs 数组存储各个阶段的三维模型，growthSprites 数组保存二维图像资源，而 seasons数组则限定了适宜种植的季节范围。这种数组相对应的设计方式有直观性又拥有灵活性，策划人员可凭借Unity 编辑器轻松配置不同作物的生长特性，而无需编写代码，系统还借助TotalGrowthDays 属性计算作物的总生长周期，为收获判断以及生长百分比计算提供便利。  

生长阶段所运用的控制逻辑运用了倒序遍历这种优化算法，在需要对作物进行显示之际，系统会依据当前已经历的生长天数，从后往前逐一检查各个生长阶段的时间阈值，直至寻觅到与之匹配的阶段索引，该算法规避了累加计算所带来的复杂性，提升了运行效率，在作物种类繁多且生长阶段较为复杂的情形下，优势极为较大。在确定生长阶段以后，系统会加载相应的预制体并设置恰当的贴图，让作物的视觉呈现可与生长进度精准契合，收获系统的设计充分顾及了游戏玩法的多样程度以及交互过程中的趣味性，系统首先会查验玩家所使用的工具是否契合当前作物的收获操作，比如使用镰刀来收割小麦、运用斧头去砍伐树木等。当工具匹配成功后，系统会按照预设的收获次数要求来累计玩家的操作次数，一旦达到相应要求便会触发收获逻辑，在收获流程里，系统会依据作物的类型来执行不同的视听效果：对于普通的农作物而言，或许是较为简单的收获动画以及音效，而对于树木类作物来说，则会播放更为复杂的倒下动画，并且依据玩家与树木之间的相对位置来决定倒下的方向，以此提高真实感以及互动性。  

系统对作物多样性的精细支持十分突出，每一种作物都可设置独特的生长特性，像是生长速度、产量范围、工具需求以及收获难度等，某些特殊的作物还支持多次收获的功能，借助 daysSinceLastHarvest 计数器以及 regrowTimes 参数，达成采摘后再次生长的机制，为游戏增添了策略方面的考量。季节对作物的影响也得到了精心模拟，不适宜的季节会致使作物生长停滞或者死亡，强化了资源管理以及时间规划方面的游戏性。  

种植系统整合了其他游戏系统，部分核心代码可见图4.18，例如种植系统与时间系统联动，响应每日更新事件推进作物生长；与地块系统协作，检查土壤状态和水分影响生长速度；与物品系统交互，处理种子使用和收获物品生成；与玩家工具系统配合，实现各类农具的差异化功能。  

![](images/12153a90ccf55bd403494c3fcde5cb296c33c736071ed6d2679f3818729b3bc0.jpg)  
图 4.18 种植系统与时间系统联动核心代码  

从技术实现这个角度去看，种植系统运用了对象池模式来管理作物实体，如此一来有效地减少了因频繁进行实例化以及销毁操作而产生的性能消耗，该系统还实现了状态缓存以及脏标记机制，其核心代码可在图4.19 中看到，系统仅仅是在有必要的时候才会去更新作物的视觉状态，对渲染性能起到了优化的作用。这些技术细节尽管对于玩家而言是不可见的，却为流畅的游戏体验奠定了相应的基础，在作物数量变得庞大的中后期游戏阶段，有着较为关键的意义。  

![](images/3e04a6b91381affecef22ebb000c4bb46787204f250d510d880aa8ac25300761.jpg)  
图 4.19 状态缓存和脏标记核心代码  

种植系统通过精心设计的数据结构和状态管理，最终种植功能实现如图4.20。  

![](images/7266d901a106cc68723616bbc0c0e5491e73a788879743967a321ac649251e7e.jpg)  
图 4.20 种植功能展示  

# 4.3.8 游戏交易系统设计与实现  

交易系统中构建一个简洁流畅的经济循环，通过与UI 交互与数据逻辑完成交易的基础设计，围绕买卖双方的资源流转来便捷交易与游戏经济，使其更加可玩耐玩。  

在交互设计上，系统通过NPCFunction 类为商人NPC 赋予开设商店的能力。当玩家与商人交互时，OpenShop 方法会触发事件显示商店界面并暂停游戏：  

public void OpenShop()   
{ isOpen $\ c =$ true; EventHandler.CallBaseBagOpenEvent(SlotType.Shop, shopData); EventHandler.CallUpdateGameStateEvent(GameState.Pause);   
}  

商店数据通过 InventoryBag_SO 类型的 ScriptableObject 管理，每个商人拥有独特的商品列表。这种配置方式让策划人员可以在Unity 编辑器中直观设置商品组合，无需编程。商店界面由InventoryUI 类动态生成，接收到开店事件后，根据商店类型选择UI 模板并填充商品数据：  

private void OnBaseBagOpenEvent(SlotType slotType, InventoryBag_SO bag_SO)  
{GameObject prefab $\mathbf { \Sigma } =$ slotType switch{SlotType.Shop $\Rightarrow$ shopSlotPrefab,// ...其他类型};// 动态生成商品槽位  

for (int $\mathbf { i } = 0$ ; $\mathrm { i } <$ bag_SO.itemList.Count; $\mathrm { i } { + } { + }$ ){ var slot $\ c =$ Instantiate(prefab, parent).GetComponent<SlotUI>(); slot.slotIndex $\mathbf { \tau } = \mathbf { i }$ ; // ... } }  

交易操作基于直观的拖拽交互。系统监听SlotUI 的拖拽事件，判断起点和终点槽位类型，触发相应的交易流程：  

// 从商店拖到背包触发购买 else if (slotType $\scriptstyle = =$ SlotType.Shop && targatSlot.slotType $\scriptstyle = =$ SlotType.Bag){  

EventHandler.CallShowTradeUI(itemDetails, false);   
}   
// 从背包拖到商店触发售卖   
else if (slotType $\scriptstyle =$ SlotType.Bag && targatSlot.slotType $\scriptstyle = =$ SlotType.Shop){  

EventHandler.CallShowTradeUI(itemDetails, true); }  

价格系统通过基础价格(itemPrice)和卖出折扣率(sellPercentage)维持经济平衡，可以基于供需关系的进行动态定价，通过监控玩家交易行为和NPC 需求变化，实时调整商品价格，模拟真实市场的价格波动，为此设计了商品供需的数据结构方便计算动态价格和更新供需关系：  

[System.Serializable]   
public class MarketData   
{ public int itemID; public float basePrice; // 基础价格 public float currentDemand; // 当前需求度 (0-2.0) public float currentSupply; // 当前供应度 (0-2.0) public float priceVolatility; // 价格波动系数 public Queue $<$ float> priceHistory; // 价格历史记录   
}  

计算动态价格就可以通过供需比例、价格波动以及价格范围限制保持在合理的区间，售卖物品时应用折扣确保“买入-卖出”循环无法产生无风险套利，维持经济平衡，核心代码可见图4.21。  

![](images/a5ac62029bacab3b9b2b9b371d96ebbdc33e66b10840f5e1ebacb6af6100b172.jpg)  
图 4.21 维持经济平衡核心代码  

交易系统会开展严格的安全检查工作，以此保证交易可在游戏规则范围之内顺利完成，像是会对玩家金钱是否充足以及背包空间是否足够等情况进行查验，全部交易借助InventoryManager 统一接口加以处理，保障数据的一致性，图4.22 呈现出了交易界面经过精心设计后的样子，其左侧是玩家背包，右侧是商店商品，处于中间位置的交易确认面板将物品信息、价格以及数量选择器清晰地显示了出来。该界面设计依照游戏整体的像素风格，保证了功能区域划分清晰以及操作有直观性，凭借这种对用户友好的界面设计以及严密的交易逻辑，系统成功搭建起了一个兼具真实性与平衡性的游戏内经济体系，为玩家给予了丰富的交易体验以及策略选择。  

![](images/0ac25aef829e17b3003e2a72919a6add7b612981af0c739f7df341d797b85627.jpg)  
图 4.22 交易界面展示  

# 4.3.9 游戏 NPC 交互系统设计与实现  

NPC 系统打造出一个动态的虚拟社区，借助“日程驱动加上智能寻路”达成NPC的自主行动以及自然移动，每一个NPC 都有着个性化的日程安排，会依据时间自动去执行任务，呈现出真实的生活节奏，极大地提高了游戏的沉浸感。  

日程系统是由 SchedulDataList_SO 进行定义的，运用 SortedSet 来管理任务的顺序，方便进行高效的查询以及编辑。策划人员可在Unity 当中直观地配置NPC 的行为，而不需要进行编程操作，NPC 每分钟会响应游戏时间的更新，依据时间、季节等条件来判断自身行为，呈现出类似早出晚归、四季分明的生活逻辑，提高了世界的连贯性，路径规划采用的是A\*算法，支持在同一场景内进行导航以及跨场景的路径计算，保证NPC 可自然地移动到任意位置，适应复杂的地图结构。搜索目标地块采用的是螺旋算法，支持在同一场景内多个NPC 查找需要完成任务的地方，保证NPC 能够可自然地到达符合条件的目标地块，识别瓦片地图同样也适应复杂地图结构。移动控制利用协程来计算速度，基于目标时间进行平滑推进，并且处理避障以及碰撞问题，保证行为时间的精确性以及视觉上的自然效果，动画系统会动态地调整NPC 的朝向以及动作，并且支持行为动画的切换以及过渡，提升了NPC 的表现力以及细节丰富程度，对话系统结合了AI 驱动以及个性参数，实现自然语言的交互，NPC 可依据背景以及性格做出多样的回应，支持上下文记忆，提升了互动的真实感。系统设计考虑到了稳定性以及体验方面，包含视觉反馈、超时处理以及容错机制，保证对话体验的流畅性，NPC 系统与时间、地图、事件等系统进行了深度整合，凭借对象池来优化性能以及表现，让NPC 成为推动游戏世界运行的关键引擎。  

图4.23 和图4.24 呈现出了对话系统的用户界面，玩家可借助输入框随意提问，而NPC 的回复是以对话气泡的形式给予显示，该界面的设计简洁且明晰，和游戏的整体风格维持一致，保证了交互过程自然又流畅，凭借这一完备的NPC 系统，游戏成功营造出了一个充满活力的虚拟社区，NPC 不再只是单纯的功能提供者，而是成为了有独特个性以及生活规律的虚拟居民，为玩家给予了丰富多样的社交体验以及探索乐趣。  

![](images/87ca16eaa67fce26cac978ebb2b5f052e2ef573a0e5622722eeb173a0727d51f.jpg)  

![](images/01f9349f883d9c91c25a946aff65647146ac577dcaa76714ea481cd41e455906.jpg)  
图 4.23 NPC 输入对话界面展示  
图 4.24 NPC 回复界面展示  

同时，本项目还对NPC 进行了行为控制，可以使其进行自动寻路耕种，具体而言通过行为树和状态机的复合架构实现智能农业自动化管理。如图4.25 所示，系统核心由NPCFarmingTask 作为任务执行器和 NPCFarmingManager 作为全局管理器构成，前者负责单个NPC 的完整耕种流程控制，后者统一协调多个NPC 避免资源冲突。  

![](images/3eee421520555d8f134f2cc5a94f11667ea1ea165482192879b02ff330742cc6.jpg)  
图 4.25 NPC 自动农耕设置图  

如图4.26 该系统的智能管理呈现于多个层面，季节适应性种植能依据当下季节自动挑选最佳种子类型，且每种作物都配备了偏好季节与优先级，地块占用管理借助HashSet来存储已被占用的位置，当NPC 开启任务时进行注册占用，任务完成后便会自动释放，如此可有效避免多个NPC 选择相同地块而引发冲突。并发任务调度将同时耕种的NPC数量限制为3 个，借助任务队列管理来保障资源得以合理分配，完成任务的NPC 会进入休息状态，等待下一轮调度。  

![](images/a081d58448b18bd50b10719d3bfd0dca7833ce1dda3b483383ab9500446eb4b6.jpg)  
图 4.26 NPC 自主寻找土地并耕种展示图  

整个系统与游戏里的时间系统、作物生长系统以及地图管理系统进行了深度整合，种植的作物可自动进入生长周期，依据CropManager中所配置的生长阶段逐渐更新外观，支持场景切换以及数据持久化，以此保障游戏世界的连续性与一致性，借助这种多层次协同的实现办法，NPC 种田系统达成了高效的自动化农业管理，同时为玩家呈现出一个充满生机且行为合理的虚拟农场环境。同时这样的系统也将会为后期拓展其他自动功能作为范式提供参考价值。  

# 4.3.10 游戏数据存储系统设计与实现  

存储系统打造了一个可靠且灵活的数据持久化框架，以此来保证玩家的游戏进度可安全地进行保存以及加载，系统设计的核心在于基于接口的组件注册机制以及JSON 序列化存取，这种组合契合了游戏数据管理的复杂需求，还维持了代码的高度解耦以及良好的可维护性，在模拟经营类游戏当中，存储系统非常关键，它要处理从玩家角色状态、物品库存到农场布局、NPC 关系等大量的异构数据，而本系统凭借精心的架构设计成功应对了这一挑战。  

系统的基础是ISaveable 接口，代码如下：   
public interface ISaveable { string GUID { get; } GameSaveData GenerateSaveData(); void RestoreData(GameSaveData saveData); void RegisterSaveable(); }  

它明确了可保存组件所应有的核心能力，分别是唯一标识、注册机制、数据生成以及恢复功能，这样的接口化设计呈现出了“面向接口编程”这一软件工程的最佳实践范例，它让存储系统与具体的游戏功能实现了解耦，仅仅聚焦于数据的保存以及加载逻辑，而不需要去了解各个组件的具体实现细节情况。当游戏里的一个组件需要支持存储功能时，只要实现这个接口并且注册自身，就可毫无妨碍地融入到存储框架当中，不需要对现有的代码进行修改，这种扩展机制极大程度上简化了新功能的添加流程，提高了开发的效率以及代码的质量，其中GUID 是系统的关键设计元素之一，它为游戏里的每个可保存实体提供了独一无二的标识。系统借助DataGUID 组件自动为实体生成并且维护GUID，以此保证在保存以及加载过程中可准确地将数据与实体进行匹配，这种基于唯一标识的机制解决了传统索引或者名称方法可能会面临的冲突以及歧义问题，在处理动态生成的游戏对象时优势极为明显，GUID 的生成采用了 System.Guid.NewGuid()方法，保证了标识符有全局唯一性以及碰撞概率极低的特性，为数据的长期一致性提供了保障。  

数据组织采用了层次化的结构设计方式，GameSaveData 类作为顶层容器，包含了多个专用字典用于存储不同类型的游戏数据，这种分类存储的方式让数据结构变得清晰且有序，方便理解以及维护，每个字典都以GUID 或者其他唯一键作为索引，存储相应类型的具体数据。比如说，characterPosDict 用于存储角色位置信息，tileDetailsDict 管理地块详情，inventoryDict 保存背包内容，timeDict 记录时间状态等等。  

序列化策略是存储系统的技术核心所在，本项目选择了JSON 作为序列化格式，这一决策综合考虑了多方面因素，JSON 格式有良好的可读性以及跨平台兼容性，方便进行调试以及问题排查，其文本化特性使得存档文件可方便地在不同设备之间进行迁移。  

![](images/cbf99dca0a9e3ffc41500143425f03a869b97bd0cef6700d27d0675b9f434f91.jpg)  
图 4.27 注册与保存时序图  

存储流程如上图4.27，SaveLoadManager 负责统一管理，其采用单例模式，为游戏打造集中的存储接口，保存时，管理器先收集当前场景信息，接着遍历注册的可保存组件列表，调用各组件的 GenerateSaveData 方法获取数据并整合进 GameSaveData 对象。完成数据收集后，系统把GameSaveData 序列化为JSON 字符串，写入磁盘文件，同时做简单的文件正确性验证，保障存档完整性，加载过程相反，系统先读取文件内容并反序列化为GameSaveData 对象，再遍历所有已注册的可保存组件，调用它们的RestoreData方法，把相应数据分发给各组件恢复。  

该项目系统充分考量了场景转换与对象生命周期的复杂性，游戏进行场景切换时，SaveLoadManager 会妥善处理组件的注册与注销，保证数据的连续性，对于动态生成的对象，系统设有注册延迟和优先级机制，保证对象能在合适时机参与存储流程，另外系统实现了自动保存功能，能在关键游戏节点或固定时间间隔自动触发存储操作，降低玩家数据丢失风险。  

错误处理是存储系统的关键部分，保证在各种异常情况时系统依然稳定，项目实现过程中注重完善异常捕获和日志记录机制，专门处理文件访问错误、序列化异常和数据一致性问题等常见故障，检测到存档损坏或不兼容时，会给出存档情况的提示说明，图4.28清晰展示了读档流程，借助存储系统，游戏可成功达成数据持久化，结果可见图4.29。  

![](images/262799d8d3168950da4c27b887e92f4ae277b8846da56cdcd26e3666f92a38b3.jpg)  

![](images/6595686ee7a4ce63a70bace7c98fffc54fc7fe286c27a6cbd95fe21d07c00849.jpg)  
图 4.28 加载流程时序图  
图 4.29 读取存档信息展示  

# 4.4 模拟经营游戏性能优化分析  

本项目于游戏开发里运用多层次性能优化策略，涉及资源管理、路径寻路、地图加载、UI 与动画系统等诸多方面，底层运用Unity 对象池管理机制，借助PoolManager 针对频繁使用的对象比如特效、音效等开展分类管理以及复用，以此减少内存分配以及GC 压力，音效池采用队列结构，保证播放时序以及自动扩容能力。  

# 4.4.1 游戏 NPC 寻路优化策略  

寻路算法作为NPC 智能行为里的关键部分，它的性能会直接对游戏的整体表现产生影响，在这个项目当中，从多个方面对NPC 主要采用的A\*算法做了优化。  

正常的A\*算法流程如图4.30 所示：  

![](images/13e5ca876456373e472e44e41c882491a77a34b0891acf71d870c757631810b1.jpg)  
图 4.30 正常 $\mathsf { A } ^ { * }$ 算法流程  

在启发式函数优化这一块，运用了把曼哈顿距离和对角线移动结合起来的混合距离计算方式，直线移动的代价设为10，对角线移动的代价设为14，启发式函数的公式是$\mathrm { H } ( \mathfrak { n } ) =$ min(xDistance, yDistance) $\mathbf { \nabla } \times 1 4 + | \mathbf { x } |$ Distance - yDistance| $\times 1 0$ 。这样的设计保证了启发式函数有可接受性，不会高估实际代价，同时依据地形的复杂程度动态调整启发式权重，在开阔地形降低权重以提高搜索速度，在复杂地形提高权重来保证路径质量。  

数据结构优化采用了高效的节点管理办法，开放列表使用List<Node>并配合自定义排序，保证 F 值最小的节点能优先被处理，关闭列表使用HashSet<Node>，Contains 操作的时间复杂度是 O(1)，比 List 的 O(n)性能要好很多。节点实现了 IComparable<Node>接口，支持高效排序，同时引入内存池化技术，凭借复用节点对象避免频繁进行垃圾回收，有效减轻内存分配的压力。  

搜索空间优化实现了分层寻路系统，大范围导航利用粗糙网格快速规划主路径，局部精细化则用详细网格处理障碍物绕行，明显减少搜索节点的数量，提高计算效率，特别是在目标搜索阶段中采用螺旋搜索算法作为A\*算法的前置优化器，从中心点开始按照螺旋轨迹向外扩展搜索，按距离从近到远排序候选位置再优先检查近距离目标，这种方法能够将平均 $\mathbf { A } ^ { * }$ 算法的调用次数从314 次降低到25 次，搜索耗时从250ms 减少到$2 0 \mathrm { m s }$ ，性能提升达 $92 \%$ ，同时确保NPC 选择最优的近距离目标，进一步简化后续的A路径计算复杂度。  

智能剪枝策略包含设置最大搜索半径，超出范围就直接返回失败，实现早期终止条件，当开放列表为空或者搜索时间超时就停止，以及路径不可达预判，检测起点和终点的连通性。  

路径缓存机制依靠路径复用优化大幅提升了性能，系统缓存常用路径，相同起终点直接返回缓存结果，使用LRU 算法管理缓存防止内存溢出，地图变化时智能使相关缓存失效。增量更新策略用 Dictionary<string, Stack<MovementStep>>存储路径缓存，凭借组合起点、终点和场景名称生成唯一键值。  

并发寻路优化采用协程分帧计算，把寻路计算分散到多帧去执行，避免单帧出现卡顿，每帧处理固定数量的节点来保持帧率稳定，在关键循环中使用yield return null 让出控制权。多NPC 任务调度实现任务队列管理，避免同时计算多个复杂路径，设置最大并发寻路数量限制为3 个，采用优先级调度保证紧急任务优先处理。  

动态避障机制实现了实时障碍物检测，NPC 移动过程中持续检查路径的有效性，检测到新障碍物时触发路径重规划，使用事件驱动架构避免轮询检测。路径平滑处理消除不必要的转折点，生成更自然的移动轨迹。  

如图4.31 所示，经过优化后，首先在判断路径缓存是否命中前就对搜索空间进行了优化。  

![](images/bcfbff2753edfdc38855c3c5d87412d1602817642e01f2d6f4cc37be18d25bfc.jpg)  
图 4.31 搜索空间优化图  

如图4.32 所示，之后通过判断是否有路径缓存命中，通过缓存机制提高返回路径效率。  

![](images/6b35747ac4b51180517923e9e642b9a49518e07b9ab1a773bb930ece5044a711.jpg)  
图 4.32 缓存机制优化图  

如图4.33 所示，如果路径缓存没有命中，将使用数据结构优化、启发式函数优化以及并发优化后的A\*算法。  

![](images/33f277dd1ef3276c000f8e485ecbdd64782955c58085ea3fee52bcb7758ffff0.jpg)  
图 ${ 4 . 3 3 \mathrm { \ A ^ { * } } }$ 算法自身优化  

如图4.34 所示，最后还要实现实时的动态避障，对碰撞层进行检测，实现最优路径返回，保证NPC 寻路有效性。  

![](images/39a5a9cd3c38f0f1d5b0cb1c84f5e84e3acd6b075ddceefb160113e085b4bb45.jpg)  
图 4.34 动态避障优化图  

# 4.4.2 对象池技术与内存管理优化  

本项目运用 Unity 内置的 ObjectPool<GameObject>系统达成高效的对象管理，借助预创建常用对象来防止运行时频繁进行实例化操作，针对不同类型的特效构建独立的对象池，如叶子掉落、石头以及收割等特效类型，该系统有自动扩容机制，在对象数量不足时会动态创建新对象，借助协程ReleaseRoutine 自动回收特效对象，1.5 秒之后将对象归还至对象池。  

音效对象池运用传统队列Queue<GameObject>实施管理，达成智能扩容机制，当队列中的对象少于2 个时会自动创建20 个新对象，依据音频长度自动回收音效对象，这种设计切实降低了内存分配峰值 $65 \%$ ，极大减少了垃圾回收频率。  

# 4.4.3 多线程处理与 Job System 优化  

该项目启用了Unity Burst 编译器，此编译器可把C#代码编译成高度优化的本机代码，其支持SIMD 指令集，也就是SSE2 以及AVX2，这使得数学计算性能得到了较大提升，同时凭借自动向量化循环操作，并行计算效率也得以提高，在物理系统多线程处理方面，于 Physics2DSettings 中启用了 Job System，针对不同类型的物理计算进行 Job分配，其中碰撞检测每Job 处理100 个接触点，岛屿求解器每Job 处理50 个刚体，触发器更新每Job 处理100 个接触点。这样的优化让CPU 使用率降低了 $40 \%$ ，达成了稳定的60FPS 帧率表现。  

# 4.5 美术资源管理  

本项目所使用的美术资源包包含以下授权类型：商业购买素材：通过 Unity Asset Store 采购 M Farm RPG Assets Pack。  

# 第 5 章游戏测试及运行效果总结  

# 5.1 游戏测试案例  

本项目采用了系统化的测试方法进行多维度、多层次的测试用例设计，较为全面验证了游戏系统的功能完整性和性能稳定性，力求测试案例的设计遵循“由点到面、由简到繁”的原则以覆盖游戏的核心功能模块和关键性能指标。  

# 5.1.1 角色控制系统测试用例  

表5.1 的测试用例主要用于对游戏里角色控制系统的核心功能展开测试，这些功能有移动、碰撞、交互、状态切换以及动画播放等，测试的目的在于验证角色在操作过程当中的响应准确性和自然性，以此来保证玩家可拥有流畅的操作体验，设计此表的来为了较为全面地覆盖常见的交互场景，提升控制逻辑的稳定性。在测试过程中需要留意响应延迟、动画过渡是否自然、碰撞判定是否准确以及交互是否灵敏等方面，防止因控制出现异常而对游戏体验产生影响。  

表 5.1 角色控制系统测试用例表  


<html><body><table><tr><td>用例 编号</td><td>测试内容</td><td>测试步骤</td><td>预期结果</td><td>实际 结果</td></tr><tr><td>UC-001</td><td>WASD方 向键移动</td><td>1.进入主场景 2.按下W/A/S/D 键</td><td>角色能够分别向上、下、左、 右移动，动画过渡自然</td><td>符合 预期</td></tr><tr><td>UC-002</td><td>障碍物碰 撞检测</td><td>1.控制角色移动 到障碍物前 2.尝试穿过障碍 物</td><td>角色无法穿过障碍物，被阻 挡在正确位置</td><td>符合 预期</td></tr><tr><td>UC-003</td><td>与交互物 体互动</td><td>1.移动角色到可 交互物体前 2.按下E键交互 按钮</td><td>显示交互界面，角色能正确 触发交互功能</td><td>符合 预期</td></tr><tr><td>UC-004</td><td>角色状态 切换</td><td>1.执行不同操作 2.观察角色状态 变化</td><td>角色在行走、奔跑、交互等 状态间切换自然流畅</td><td>符合 预期</td></tr><tr><td>UC-005</td><td>动画控制 系统</td><td>1.进行各类动作 2.观察动画播放</td><td>角色动画与实际操作同步， 过渡自然</td><td>符合 预期</td></tr></table></body></html>  

# 5.1.2 NPC 系统测试用例  

表5.2 的测试用例用于验证NPC 系统关键功能的内容，涉及了寻路、日程执行、动态避障、交互响应以及环境感知等方面，测试的以便保证NPC 行为契合设计预期，拥有一定程度的智能性与互动性，此表是从典型使用场景着手，对NPC 在复杂环境里的反应以及行为逻辑展开系统性测试，在测试过程中需要留意路径规划是否合理、行为是否会随着时间改变、避障是否可实时且有效、交互反馈是否匹配得当以及对环境的适应性状况，防止NPC 出现行为僵硬或者逻辑异常的情况。  

表 5.2 NPC 系统测试用例表  


<html><body><table><tr><td>用例 编号</td><td>测试内容</td><td>测试步骤</td><td>预期结果</td><td>实际结果</td></tr><tr><td>UC-006</td><td>基础寻路 功能</td><td>1.观察 NPC 行为 2.记录NPC从A点移 动到B点过程</td><td>NPC 能够根据 A*算法找到 最优路径，避 开障碍物</td><td>符合预期</td></tr><tr><td>UC-007</td><td>日程表功 能</td><td>1.设置游戏时间为不 同时刻 2.观察特定NPC行为</td><td>NPC 能按照预 设日程在不同 时间点执行对 应行为</td><td>符合预期</td></tr><tr><td>UC-008</td><td>动态避障 功能</td><td>1.控制角色阻挡NPC 路径 2.观察NPC反应</td><td>NPC 能检测到 动态障碍物并 重新规划路径</td><td>符合预期</td></tr><tr><td>UC-009</td><td>NPC 交互 响应</td><td>1.接近NPC 并交互 2.测试多种交互选项</td><td>NPC 根据不同 交互选项给予 相应反馈</td><td>符合预期</td></tr><tr><td>UC-010</td><td>环境感知 能力</td><td>1.改变环境条件 2.观察NPC反应</td><td>NPC 能对环境 变化（如天气、 时间）做出相 应行为调整</td><td>符合预期</td></tr></table></body></html>  

# 5.1.3 物品与背包系统测试用例  

表5.3 中的测试用例被用于对游戏里物品管理以及背包系统的核心功能展开测试，这些功能涉及了物品拾取、拖拽堆叠、使用、分类筛选以及容量限制等方面，其测试的目的在于保证物品操作有直观性且逻辑正确，可对玩家的资源管理起到有效的支持作用，本表的设计是为了覆盖玩家在物品交互过程中的常见操作。在测试进程中，需要着重关注物品状态更新是否同步、堆叠与交换逻辑是否准确、物品效果是否可正常触发，以及背包容量提示是否清晰，以此来防止操作错误或者数据异常对玩家体验造成影响。  

表 5.3 物品与背包系统测试用例表  


<html><body><table><tr><td>用例 编号</td><td>测试内容</td><td>测试步骤</td><td>预期结果</td><td>实际 结果</td></tr><tr><td>UC-011</td><td>物品拾取 功能</td><td>1.控制角色靠近可 拾取物品 2.按下拾取按键 3.检查背包界面</td><td>物品成功加入背包，数量 正确显示</td><td>符合 预期</td></tr><tr><td>UC-012</td><td>物品拖拽 与堆叠</td><td>1.打开背包界面 2.拖拽同类物品到 另一堆 3.拖拽不同物品互 换位置</td><td>同类物品能正确堆叠，不 同物品能交换位置</td><td>符合 预期</td></tr><tr><td>UC-013</td><td>物品使用 功能</td><td>1.选中可使用物品 2.点击使用按钮或 使用快捷键</td><td>物品效果正确生效，数量 相应减少</td><td>符合 预期</td></tr><tr><td>UC-014</td><td>物品分类 与筛选</td><td>1.打开背包界面 2.测试分类与筛选 功能</td><td>物品按照类别正确显示， 筛选功能正常工作</td><td>符合 预期</td></tr><tr><td>UC-015</td><td>背包容量 限制</td><td>1.尝试收集超过背 包上限的物品</td><td>背包满时显示提示，无法 继续添加物品</td><td>符合 预期</td></tr></table></body></html>  

# 5.1.4 交易系统测试用例  

表5.4 当中所罗列的测试用例是专门用来对游戏里的交易系统功能展开测试的，其中囊括了购买、售卖、批量交易、价格机制以及取消交易等一系列操作，进行这些测试的来要保证玩家和商人NPC 之间的交易逻辑清晰无误，数据处理精准正确，可支持多样化的交易场景，设计这张表的意图是要覆盖完整的交易流程以及其变种情况。在测试过程中应当着重检查金钱与物品的变化是否同步，批量交易金额的计算是否准确，价格机制是否合理，以及取消操作之后资源状态有没有被错误更改，以此来保障玩家资源的安全以及交易体验。  

表 5.4 交易系统测试用例表  


<html><body><table><tr><td>用例 编号</td><td>测试内容</td><td>测试步骤</td><td>预期结果</td><td>实际 结果</td></tr><tr><td>UC-016</td><td>商店购买 功能</td><td>1.与商人NPC交 互 2.选择商品 3.点击购买 4.确认交易</td><td>金钱正确扣除，物品加入背 包</td><td>符合 预期</td></tr><tr><td>UC-017</td><td>物品售卖 功能</td><td>1.与商人NPC交 互 2.从背包选择物 品 3.点击售卖 4.确认交易</td><td>物品从背包移除，金钱正确 增加</td><td>符合 预期</td></tr><tr><td>UC-018</td><td>批量交易 功能</td><td>1.与商人交互 2.选择商品 3.调整数量到多 个 4.完成交易</td><td>正确计算总价，批量添加物 品到背包</td><td>符合 预期</td></tr><tr><td>UC-019</td><td>价格机制 测试</td><td>1.出售不同类型 物品 2.观察售价与标 价的关系</td><td>物品售价符合预设的折扣 比例</td><td>符合 预期</td></tr><tr><td>UC-020</td><td>交易取消 功能</td><td>1.开始交易 2.取消交易 3.确认物品和金 钱状态</td><td>交易被取消，物品和金钱状 态保持不变</td><td>符合 预期</td></tr></table></body></html>  

# 5.1.5 时间与环境系统测试用例  

表5.5 用来对游戏里时间与环境系统的核心功能展开测试，其中囊括时间的流逝、季节的变换、昼夜的交替，以及时间对于NPC 行为以及游戏机制所产生的影响，测试的以便去查验系统时间对于场景以及逻辑触发的联动效果是不是精准，以此达成更为真实的世界构建，测试的时候要留意时间推进是不是平稳、环境视觉变化是不是自然、时间驱动行为是不是契合预设规则，防止出现时间错乱、光照异常或者时间机制失效等状况，保障玩家沉浸感以及游戏节奏的一致性。  

表 5.5 时间与环境系统测试用例表  


<html><body><table><tr><td>用例编 号</td><td>测试内容</td><td>测试步骤</td><td>预期结果</td><td>实际 结果</td></tr><tr><td>UC-021</td><td>时间流逝功 能</td><td>1.观察游戏UI上 的时间显示 2.等待一段时间 3.再次检查时间 显示</td><td>游戏时间按设定比例流 逝，UI正确更新</td><td>符合 预期</td></tr><tr><td>UC-022</td><td>季节变化功 能</td><td>1.使用时间控制 功能快进多天 2.观察季节变化</td><td>季节正确变化，环境视觉 效果相应调整</td><td>符合 预期</td></tr><tr><td>UC-023</td><td>昼夜变化功 能</td><td>1.观察游戏场景 光照 2.等待游戏内时 间从白天到黑夜</td><td>光照强度和颜色随时间 变化，夜晚场景变暗</td><td>符合 预期</td></tr><tr><td>UC-024</td><td>时间对NPC 的影响</td><td>1.观察不同时间 点NPC 行为</td><td>NPC 行为随时间变化而 改变，符合日程安排</td><td>符合 预期</td></tr><tr><td>UC-025</td><td>时间对游戏 机制的影响</td><td>1.测试时间敏感 的游戏机制 (如商店营业时 间)</td><td>游戏机制随时间变化而 改变，如商店关闭、开放</td><td>符合 预期</td></tr></table></body></html>  

# 5.1.6 种植系统测试用例  

表5.6 是用来对游戏里的种植系统功能展开测试的，其中囊括了播种、作物生长、收获、季节影响以及土地管理等核心方面，测试的以便保证作物生命周期的逻辑清晰，可和时间以及环境系统准确地联动起来，在测试的过程当中，需要着重去关注作物生长是不是按照周期发生变化、不同季节对作物状态所产生的影响是不是合理，以及播种和土地状态变化是不是同步，防止出现作物没办法收获、生长出现异常或者土地状态出现错误等情况，以此保障系统有可用性和可拓展性。  

表 5.6 种植系统测试用例表  


<html><body><table><tr><td>用例编 号</td><td>测试内容</td><td>测试步骤</td><td>预期结果</td><td>实际 结果</td></tr><tr><td>UC-026</td><td>播种功能</td><td>1.选择种子物 品 2.在可耕种土</td><td>土地状态变为已种植，显示对 应作物初始阶段</td><td>符合 预期</td></tr></table></body></html>  

基于 Unity 的模拟经营游戏的设计与实现  


<html><body><table><tr><td>用例编 号</td><td>测试内容</td><td>测试步骤</td><td>预期结果</td><td>实际 结果</td></tr><tr><td rowspan="2">UC-027</td><td>作物生长</td><td>地上使用 3.查看土地状 态 1.种植作物后 2.通过时间系</td><td>作物按照预设生长周期逐步</td><td>符合</td></tr><tr><td>功能</td><td>统推进多天 3.观察作物变 化 1.等待作物完 全成熟</td><td>成长，视觉表现正确更新 成熟作物被收获，对应收获物</td><td>预期 符合</td></tr><tr><td>UC-028</td><td>收获功能</td><td>2.与成熟作物 交互 3.检查背包 1.在不同季节</td><td>品进入背包</td><td>预期 符合</td></tr><tr><td>UC-029</td><td>季节对作 物的影响</td><td>种植同一作物 2.观察生长情 况 1.使用工具处</td><td>作物生长速度和状态受季节 影响，符合预期设计</td><td>预期</td></tr><tr><td>UC-030</td><td>土地管理 功能</td><td>理土地 2.观察土地状 态变化</td><td>土地状态正确变化，如从未耕 种变为已耕种</td><td>符合 预期</td></tr></table></body></html>  

# 5.1.7 系统性能测试用例  

表5.7 被用来对游戏系统在高负载以及长时间运行状况下的性能表现展开测试，其中涉及寻路算法效率、对象池复用情况、物品操作响应速度、场景切换性能以及整体系统稳定性等多个方面，其测试目的在于保证关键系统在复杂或者极限条件之下依旧可维持流畅运行状态，在测试过程中，需要着重留意GC 频率、内存波动、帧率稳定性以及操作响应延迟等情况，避免出现性能瓶颈、卡顿或者崩溃等问题，以此保障游戏运行有流畅性与可靠性。  

表 5.7 系统性能测试用例表  


<html><body><table><tr><td>用例编 号</td><td>测试内容</td><td>测试步骤</td><td>预期结果</td><td>实际 结果</td></tr><tr><td>UC-031</td><td>A*寻路性</td><td>1.设置复杂场景中</td><td>寻路计算在可接受时间</td><td>符合</td></tr></table></body></html>  

基于 Unity 的模拟经营游戏的设计与实现  


<html><body><table><tr><td>用例编 号</td><td>测试内容</td><td>测试步骤</td><td>预期结果</td><td>实际 结果</td></tr><tr><td rowspan="2">UC-032</td><td>能测试</td><td>多个NPC 同时寻路 2.监控性能</td><td>内完成，不造成明显卡顿</td><td>预期</td></tr><tr><td>对象池系统 效率测试</td><td>1.短时间内频繁触 发特效/音效 2.监控内存分配</td><td>对象成功复用，无频繁 GC，内存使用稳定</td><td>符合 预期</td></tr><tr><td>UC-033</td><td>大量物品操 作测试</td><td>1.同时管理大量物 品 2.执行频繁的物品 操作 3.监控响应时间</td><td>系统响应及时，物品操作 不造成明显延迟</td><td>符合 预期</td></tr><tr><td>UC-034</td><td>场景切换性 能测试</td><td>1.频繁进行场景切 换 2.监控加载时间和 内存使用</td><td>场景切换流畅，加载时间 短，内存使用稳定</td><td>符合 预期</td></tr><tr><td>UC-035</td><td>长时间运行 稳定性测试</td><td>1.游戏连续运行数 小时 2.执行各种操作 3.监控内存和性能</td><td>无内存泄漏，性能保持稳 定，不出现崩溃</td><td>符合 预期</td></tr></table></body></html>  

# 5.2 游戏运行效果总结  

# 5.2.1 游戏功能运行效果总结  

经过系统化测试以及长时间的gameplay 测试，游戏系统于功能方面呈现出了优良的质量以及较高的完成度，各核心功能模块的运行效果具体分析如下：角色控制系统运行效果颇佳，玩家与游戏世界的交互顺畅自然，控制方案选用了经典的WASD 移动模式，搭配鼠标交互，给玩家给予了直观易用的操作体验。角色的移动动画达成了八方向过渡，保证了在任何方向发生变化时可自然平滑，角色与环境的碰撞检测机制值得关注，如图5.1 借助精确的碰撞盒设计以及物理材质调整，有效规避了常见的“卡墙”和“穿模”问题，交互系统的设计也较为巧妙，当玩家靠近可交互对象时，界面会显示简洁的提示图标，按下交互键后可快速响应，这种设计保证了操作的简便性，又提升了游戏世界的沉浸感。  

![](images/223433dcfe9864eb8325507f0c7fad622de4ca8278e76400ad4d1d5f9fc50263.jpg)  
图 5.1 角色奔跑与碰撞层展示  

NPC 系统是这款游戏中相当突出的功能模块，其基于行为树以及 $\mathbf { A } ^ { * }$ 寻路算法来设计，使得NPC 呈现出了近似真实的生活规律与行为模式，每一个NPC 都有着独特的日程表，会在特定的时间前往特定的地点去执行预先设定好的行为，测试结果说明，哪怕是在复杂的地形以及多个NPC 同时活动的状况下，该系统也可维持高效的路径规划以及行为执行。动态避障功能表现优异，当NPC 的预设路径被玩家或者其他动态障碍物阻挡时，它可实时重新计算路径，避开障碍物继续前行，这种智能的环境适应能力极大地提高了游戏世界的真实感与活力。  

物品与背包系统的运行成效体现出了出色的用户体验设计，物品交互采用了直观的拖拽操作方式，支持物品的移动、堆叠以及分类管理。系统可正确处理同类物品的自动堆叠、不同物品的位置交换以及物品数量的拆分等一系列复杂操作，背包界面的布局清晰且合理，物品图标设计鲜明，数量显示醒目，让玩家可轻松地管理大量物品，物品使用功能也运行稳定，各类物品的效果可正确触发，使用后的状态变更会及时反馈。背包容量限制机制提供了适度的游戏挑战，当背包快要满的时候，系统会给出明确的提示，避免玩家错失关键物品。  

交易系统在实际运行过程中呈现出了良好的经济平衡以及交互流畅性，玩家可凭借与商人NPC 交互来打开商店界面，系统会依据不同商人类型显示对应的商品目录，购买和售卖操作设计简洁又高效，依靠点击或者拖拽便可完成。批量交易功能非常实用，玩家可以借助数量调节器快速设定交易数量，系统会自动计算总价并检查金钱以及库存是否充足，价格机制的实现也颇具深度，不同商人对同一物品可能会提供不同价格，而玩家售出物品时的价格则依据预设的折扣比例来计算，这种机制符合经济规律，又为游戏增添了策略性。测试结果显示，即便在进行复杂的多物品交易操作时，系统也可保持数据的准确性以及界面的响应性。  

时间与环境系统作为模拟经营游戏里关键的核心机制之一，在实际的运行过程当中呈现出了相当不错的表现力以及稳定性，游戏里面的时间依照设定好的比例进行流逝，借助UI 界面可直观地展示出当下的时间、日期以及季节，昼夜更替所产生的视觉效果是依靠全局光照以及后处理效果达成的，白天的场景显得明亮而又温暖，夜晚的时候则会慢慢变暗并且带有蓝调，这样的变化强化了游戏的视觉表现，还为游戏玩法增添了在时间维度方面的策略考量，季节变化系统的运行效果同样让人感到满意，不同的季节会对作物生长产生影响，让游戏世界更加契合现实直觉，提高玩家的代入感。测试结果说明，时间系统和其他游戏系统联动运行十分顺畅，不管是NPC 日程、商店营业时间还是作物生长周期，都可依据时间的变化准确地做出响应。  

![](images/79d072ef70f650750ace1362497c2827cc809f69f584a7ca972d96a582c6ac7d.jpg)  
图 5.2 NPC 夜晚 NPC 打哈欠动画  

种植系统在运行过程中呈现出了可模拟完整农作物生命周期的能力，从土地开始进行耕作，接着进行播种，一直到作物生长以及收获的整个过程，该系统都提供了直观的视觉反馈以及交互操作，作物生长阶段的变化，借助精心设计的生长周期以及与之对应的视觉资源，玩家可清晰地辨别出作物的生长状态。季节对作物生长的影响机制运行状况良好，不同季节会对作物的生长速度产生影响，甚至有可能致使不适宜该季节生长的作物枯萎，这种机制增加了游戏的策略深度以及挑战性，收获系统的运行效果同样出色，成熟作物在收获之后会依据预设的产出概率生成相应数量的收获物品，并且还存在返还种子的概率，这种设计契合真实农业生产规律，又平衡了游戏经济系统。  

# 5.2.2 游戏运行性能效果总结  

在性能方面，游戏系统经过全面的优化举措以及严格的测试，达成了卓越的运行效率与稳定性，以下是从多个维度针对游戏运行性能展开的分析：帧率表现是衡量游戏流畅度的关键指标，借助内置的性能监控工具收集到的数据说明，在标准测试环境下，游戏在不同场景以及负载条件下的帧率表现如下表5.8。  

表 5.8 帧率表现表  


<html><body><table><tr><td>场景类型</td><td>帧率表现</td></tr><tr><td>标准场景（少量 NPC，普通互动）</td><td>稳定保持60FPS</td></tr><tr><td>中负载场景（5-10个NPC，频繁物品操作）</td><td>平均57FPS，波动范围±3FPS</td></tr><tr><td>场景切换过程</td><td>短暂降至40FPS，但迅速恢复</td></tr></table></body></html>  

这些数据表明，游戏在各种常见使用场景下都能保持流畅的视觉体验，帧率波动控制在可接受范围内，不会对游戏体验造成明显影响。  

内存使用方面，游戏表现出了良好的资源管理能力。测试数据显示如下表5.9 和图5.3。  

![](images/3e219fef7d0451ff42b943e439c45c7522aa3c7d6060b722c4fa3cd9474d8a93.jpg)  
图 5.3 高负载场景内存占用情况  

这种稳定的内存使用模式依靠游戏中实施的多项内存优化措施，对象池系统对频繁创建销毁对象的管理也有效避免了内存碎片化和泄漏问题。  

CPU 使用率数据见表5.10，可见同样令人满意。  

表 5.10 正常游戏过程中 CPU 使用率表  


<html><body><table><tr><td>状态描述</td><td>CPU使用率</td></tr><tr><td>空闲状态（主菜单）</td><td>5-8%</td></tr><tr><td>标准游戏状态</td><td>12-20%</td></tr><tr><td>高计算负载状态（多 NPC 寻路，大量物理计算)</td><td>峰值35%，平均不超过25%</td></tr></table></body></html>  

CPU 使用的峰值主要出现在多个NPC 同时重新计算路径的情况下，但即使在这种情况下，优化后的A 算法也能高效完成计算任务，不会导致明显的性能下降。  

GPU 使用率见表5.11，可见保持在合理范围。  

表 5.11 采用 A\*算法后 CPU 使用率  


<html><body><table><tr><td>场景描述</td><td>GPU 使用率</td></tr><tr><td>标准场景</td><td>30-40%</td></tr><tr><td>视觉效果密集场景</td><td>45-55%</td></tr><tr><td>峰值使用率</td><td>不超过 60%</td></tr></table></body></html>  

这表明游戏的图形渲染进行了良好的优化，即使在视觉效果丰富的场景下，也不会对GPU 造成过重负担。  

加载时间测试结果显示见表5.12，游戏的资源管理和场景加载机制运行高效。  

表 5.12 游戏加载时间表  


<html><body><table><tr><td>加载类型</td><td>所需时间</td></tr><tr><td>游戏初始启动时间</td><td>3-4秒</td></tr><tr><td>主场景初次加载</td><td>2-3秒</td></tr><tr><td>场景间切换时间</td><td>0.5-1秒</td></tr><tr><td>存档加载时间</td><td>1-2秒</td></tr></table></body></html>  

这些数据可说明，即便在首次加载之时需要较多资源，游戏依旧可在可接受的时间范围之内完成加载，为玩家给予流畅的游戏体验，特定功能模块的性能表现同样让人感到满意，对象池系统在处理大量特效以及音效的时候表现出色，测试结果显示，使用对象池之后，特效实例化时间减少了大概 $80 \%$ ，从平均 $4 . 2 \mathrm { m s }$ 下降至 $0 . 8 \mathrm { m s }$ 。在密集触发特效的场景当中，像是多个作物同时收获的场景，内存分配峰值降低了 $65 \%$ ，有效减轻了垃圾回收所带来的压力，另外使用对象池管理音效资源之后，在同时播放多个音效的情形下，性能开销降低了大约 $70 \%$ ，保证了音效播放的流畅性， $\mathbf { A } ^ { * }$ 寻路系统在优化之后同样呈现出优异的性能。单次寻路计算的平均耗时为 $1 . 8 \mathrm { m s }$ ，即便在复杂地形以及长距离路径计算的状况下，最大耗时也可控制在9ms 以内，在多NPC 同时寻路的情况下，凭借分帧计算以及优先级排序机制，有效避免了计算堆积引发的卡顿，对网格节点的缓存以及重用机制，让重复区域的寻路计算速度提升了大约 $65 \%$ 。借助系统化的性能优化以及严格的测试验证，游戏在各个方面都呈现出了优秀的运行性能，在资源管理、NPC行为控制以及UI 交互等关键领域，系统运行稳定而且高效，为玩家提供了流畅、沉浸的游戏体验，这些性能指标契合了当前版本的需求，也为未来功能扩展以及内容丰富预留了充足的性能空间。  

# 结 论  

本研究借助 Unity 引擎设计并完成了一款农场题材模拟经营游戏的实现，项目实现了核心玩法模块的全面开发，其中有背包管理、农作物种植、商店交易、NPC 行为以及存档系统等，采用 MVC 架构、数据驱动以及现代 Unity 技术比如 ScriptableObject、UIToolkit、Job System，达成了功能清晰且有可扩展性的系统结构。性能优化措施像对象池、多线程提升了游戏流畅度，为数千实体的实时交互给予了支撑，测试结果证实了优化方案的有效，说明游戏在目标设备上可稳定运行，在教育与娱乐方面，该游戏能为玩家带来沉浸式农场经营体验，还可当作游戏开发教学示例。  

# 参考文献  

[1]汪睿.我国电子游戏产业发展及现状研究[D].成都信息工程大学,2019.  
[2]范铭君.模拟经营类游戏玩家的游戏动机与游戏行为研究[D].山东大学,2022.  
[3]谢文萱.模拟经营类国风游戏研究报告——以《江南百景图》为例[J].浙江工艺美术,2024,(01):88-90.  
[4]王东静,孙达特.数字游戏产业链的高科技属性及行业发展路径研究[J].高科技与产业化,2023,29(05):64-73.  
[5]Yuan J ,Zhang Y ,Li D , et al.Immersive human–computer interaction and digital entertainment new media application in English e-learning mode[J].Entertainment Computing,2025,52100878-100878.  
[6]Mozgovoy M .Editorial: Applications of Artificial Intelligence and Machine Learning in Games[J].Applied Sciences,2024,14(19):8782-8782.  
[7]张守营.“AI+”驱动游戏书写新篇章[N].中国经济导报,2025-03-29(004).  
[8]谭威,胡新荣,雷伟.基于 Unity 的 A-Star 算法在游戏中的具体实现[J].计算机产品与流通,2018,(11):121.  
[9]李圣杰,蒋洪伟.基于改进 A\*算法的 AGV 路径规划[J].邵阳学院学报(自然科学版),2025,22(02):19-26.  
[10]Kim E ,Kim H ,Yu K .Implementation of Adaptive Navigation for NPCs in Computer Games[J].Journal of KIISE,2016,43(2):222-228.  
[11]饶梦莎.电子游戏路径规划之寻路算法研究[J].玩具世界,2023,(04):85-87.  
[12]谭威,胡新荣,雷伟.基于 Unity 的 A-Star 算法在游戏中的具体实现[J].计算机产品与流通,2018,(11):121.  
[13]陈素琼.基于改进 A\*算法的地图游戏寻径研究[D].重庆师范大学,2016.  
[14]Izci D ,Ekinci S ,Eker E , et al.Augmented hunger games search algorithm using logarithmic spiral opposition-based learning for function optimization and controller design[J].Journal of King Saud University - Engineering Sciences,2024,36(5):330-338.  
[15]王宇轩.浅析游戏人工智能的发展与应用[J].科技传播,2019,11(02):125-126.  
[16]余晓晗,袁铎,姚昌华.面向兵棋游戏的多层级智能体架构[J].指挥控制与仿真,2025,47(01):69-76.  
[17]Adeniyi E A ,Brahma B ,Adebiyi O M , et al.Development of Two Dimension (2D) Game Engine withFinite State Machine (FSM) Based Artificial Intelligence (AI) Subsystem[J].Procedia Computer Science,2024,2352996-3006.  

# 致 谢  

本论文的顺利完成，离不开许多人的支持与帮助。在此，我谨向所有在我求学与毕业设计过程中给予我指导和鼓励的人致以最诚挚的感谢。  

首先，我要衷心感谢我的导师——邬思奇老师。邬老师严谨治学、认真负责的态度不仅指导我完成了论文的选题与写作，更让我在专业素养和科研思维上受益匪浅。在毕业设计的每一个阶段，邬老师都给予了我耐心的指导和中肯的建议，帮助我不断修正方向、提升质量。您的敬业精神和深厚学识，将成为我今后学习与工作的榜样。  

其次，我要感谢所在的湖南工程学院，感谢学院为我提供了良好的学习环境和丰富的教学资源，让我在四年的大学生活中不断成长，夯实了专业基础，拓宽了知识视野。  

我也由衷地感谢我的父母。在我学习与生活中遇到困难时，是你们给予我最坚实的后盾与最无私的支持。你们的理解与鼓励，是我坚持下去的重要动力。没有你们默默的付出与陪伴，我无法顺利走到今天。  

同时，我还要感谢我的朋友们与同学们，是你们的陪伴让我度过了一个又一个难忘的大学日夜，你们的存在让我的大学生活更加充实而温暖。  

最后，谨以此文，向所有支持和关心过我的人表示最真挚的感谢！  